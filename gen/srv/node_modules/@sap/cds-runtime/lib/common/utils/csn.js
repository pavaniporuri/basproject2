const getEtagElement = entity => {
  return Object.values(entity.elements).find(element => element['@odata.etag'])
}

const _isBacklink = (assoc, parent, target) => {
  const comps = Object.values(target.associations || {})
    .filter(assoc => assoc._isCompositionEffective)
    .filter(assoc => assoc.target === parent.name)
  if (comps.length === 0) return false

  let backlink = false
  for (const comp of comps) {
    const on = comp.on.find(ele => typeof ele === 'object' && ele.ref[0] !== '$self')
    if (on.ref.length === 2 && on.ref[on.ref.length - 1] === assoc.name) {
      backlink = true
      break
    }
  }
  return backlink
}

const _isDependent = (assoc, parent, target) => {
  return (
    assoc._isAssociationStrict &&
    assoc.is2one &&
    !assoc.on &&
    !parent['@cds.persistence.skip'] &&
    assoc['@assert.integrity'] !== false &&
    parent['@assert.integrity'] !== false &&
    (!parent._service || parent._service['@assert.integrity'] !== false) &&
    !_isBacklink(assoc, parent, target)
  )
}

/*
 * this modifies the csn on purpose for caching effect!
 * doing as aspect is difficult due to no global definitons per tenant
 */
const getDependents = (entity, model) => {
  if (entity._dependents !== undefined) return entity._dependents

  let dependents = []
  for (const def of Object.values(model.definitions)) {
    if (def.kind !== 'entity') continue
    if (!def.associations) continue

    for (const assoc of Object.values(def.associations)) {
      if (assoc.target !== entity.name) continue

      const parent = assoc.parent
      const target = model.definitions[assoc.target]
      if (_isDependent(assoc, parent, target)) {
        dependents.push({ element: assoc, parent, target })
      }
    }
  }

  if (dependents.length === 0) dependents = false
  entity._dependents = dependents
  return dependents
}

module.exports = {
  getEtagElement,
  getDependents
}
