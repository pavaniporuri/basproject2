const cds = require('../cds')
const LOG = cds.log('messaging')
const MessagingService = require('./service')
const { topic, queueName } = require('./common-utils/naming-conventions')
const optionsApp = require('./common-utils/optionsApp')
const queued = require('./common-utils/queued')

const _depcrecated = options => {
  const cred = options && options.credentials
  if (cred) {
    if (cred.prefix) throw new Error('Remove deprecated property "prefix".')
    if (cred.queue) throw new Error('Remove property "queue" from the credentials section. It is a top-level property.')
    if (cred.queueConfig) throw new Error('Use "queue". "queueConfig" is merged with the top-level property "queue".')
  }
  if (options.queue && typeof options.queue !== 'object') {
    throw new Error('Property "queue" must be an object with a property "name" and additional configuration options.')
  }
}

const _emitForSubdomain = async (msg, subDomain, srv) => {
  // create new client with new credentials
  const client = srv.getClient(subDomain)
  await client.connect()
  await client.emit(msg)
  return client.disconnect()
}

class BaseMessaging extends MessagingService {
  async init() {
    _depcrecated(this.options)
    this.optionsApp = optionsApp(this.options)
    if (this.options.queue) {
      const queueConfig = { ...this.options.queue }
      delete queueConfig.name
      if (Object.keys(queueConfig).length) this.queueConfig = queueConfig
    }
    this.optionsApp = optionsApp
    this.queueName = queueName(
      this.options,
      this.options.credentials && this.options.credentials.namespace,
      this.optionsApp
    )
    this.subscribedTopics = new Set()
    this.listening = false
    this.ready = false
    // enables queued async operations (without awaiting)
    this.queued = queued()
    this.management = this.getManagement()
    this.client = this.getClient()

    if (this.keepConnection) {
      await this.client.connect()
    }

    cds.once('served', () => {
      this.ready = true
      this.listen()
    })

    return super.init()
  }

  emit(event, ...etc) {
    const msg = this.message4(event, ...etc)
    LOG._debug && LOG.debug('Emit', { topic: msg.event })
    const subDomain =
      this.context &&
      this.context._ &&
      this.context._.req &&
      this.context._.req.authInfo &&
      this.context._.req.authInfo.getSubdomain()
    if (this.keepConnection) return this.queued(this.client.emit.bind(this.client))(msg)
    else return this.queued(_emitForSubdomain.bind(this))(msg, subDomain, this)
  }

  // inbound -> listen to channel (once)
  // only works for events in provider sub domain
  on(topic, handler) {
    if (!this.subscribedTopics.size) this.queued(this.management.putQueue.bind(this.management))(this.queueName)
    if (!this.subscribedTopics.has(topic)) {
      this.queued(this.management.addSubscription.bind(this.management))(this.queueName, topic)
      this.subscribedTopics.add(topic)
    }
    this.listen()
    return super.on(topic, handler)
  }

  listen() {
    if (this.queueName && !this.listening && this.ready) {
      this.listening = true
      this.queued(this.client.listen.bind(this.client))(this.queueName, async (_event, _payload, { done, failed }) => {
        const data = _payload.data
        const headers = { ..._payload }
        delete headers.data
        try {
          await super.emit({ event: _event, data, headers })
          done()
        } catch (e) {
          failed()
          LOG._error && LOG.error(e)
        }
      })
    }
  }

  disconnect() {
    if (this.keepConnection) return this.client.disconnect()
  }

  topic4(declared, service) {
    const event = declared.name.slice(service.name.length + 1)
    return topic(event, service, this.optionsClient)
  }
}

module.exports = BaseMessaging
