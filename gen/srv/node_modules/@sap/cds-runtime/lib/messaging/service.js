const cds = require('../cds')

class MessagingService extends cds.Service {
  init() {
    // listen for all subscriptions to declared events of remote, i.e. connected services
    cds.on('subscribe', (srv, event) => {
      const declared = srv.events[event]
      if (declared && srv.name in cds.requires && !srv.mocked) {
        const topic = declared['@topic'] || this.topic4(declared, srv)
        // we register self-handlers for declared events, which are supposed
        // to be calles by subclasses calling this.dispatch on incoming events
        this.on(topic, async (msg, next) => {
          const { data, headers } = msg
          await srv.tx(msg).emit({ event, data, headers, __proto__: msg })
          return next()
        })
      }
    })

    // forward all emits for all declared events of local, i.e. served services
    cds.on('serving', srv => {
      for (const declared of srv.events) {
        const topic = declared['@topic'] || this.topic4(declared, srv)
        const event = declared.name.slice(srv.name.length + 1)
        // calls to srv.emit are forwarded to this.emit, which is expected to
        // be overriden by subclasses to write events to message channel
        srv.on(event, async (msg, next) => {
          const { data, headers } = msg
          await this.tx(msg).emit({ event: topic, data, headers })
          return next()
        })
      }
    })

    // if outbox is switched on, decorate the emit method to actually do
    // the emit only when the request succeeded
    if (this.options.outbox) {
      const { emit } = this
      this.emit = function (...args) {
        // `this` is a srv.tx
        if (this.context) return this.context.on('succeeded', () => emit.call(this, ...args))
        return emit.call(this, ...args)
      }
    }

    const { on } = this
    this.on = function (...args) {
      if (Array.isArray(args[0])) {
        const [topics, ...rest] = args
        return topics.map(t => on.call(this, t, ...rest))
      }
      return on.call(this, ...args)
    }
  }

  emit(event, data, headers) {
    return super.emit(event instanceof cds.Event ? event : new cds.Event(this.message4(event, data, headers)))
  }

  /** Subclasses can override this method to map events to topics */
  topic4(declared, service) {
    return declared.name
  }

  /** Subclasses can use this method to create events */
  message4(event, data, headers) {
    const msg = typeof event === 'object' ? event : { event, data, headers }
    if (!msg.headers || !msg.headers.id) msg.headers = { id: cds.utils.uuid(), ...msg.headers }
    // const headers = msg.headers['x-cds-incoming-protocol'] ? {} : msg.headers -> ?????
    return msg
  }
}

module.exports = MessagingService
