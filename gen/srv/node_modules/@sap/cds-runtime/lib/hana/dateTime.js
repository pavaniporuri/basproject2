const { ensureNoDraftsSuffix } = require('../common/utils/draft.js')
const DATE_TIME_TYPE = 'cds.DateTime'
const _convertDateTimeElement = (value, element) => {
  value = new Date(value).toISOString()
  if (element.type === DATE_TIME_TYPE) {
    value = `${value.slice(0, 19)}Z`
  }
  return value
}
const _isToConvert = type => type === DATE_TIME_TYPE || type === 'cds.Timestamp'

const convertDateTimeEntry = (entry, element, model) => {
  const { name, type, _target } = element
  if (!(entry[name] === undefined || entry[name] === null)) {
    if (_isToConvert(type) && entry[name] !== '$now') {
      entry[name] = _convertDateTimeElement(entry[name], element)
    }

    if (element.isComposition) {
      convert({ target: _target, data: entry[name] }, model)
    }
  }
}

const _convertEntries = (data, elements, model) => {
  // check all entries
  for (const entry of data) {
    for (const column in entry) {
      // skip unknown columns
      if (!elements[column]) continue
      convertDateTimeEntry(entry, elements[column], model)
    }
  }
}

const _convertColumns = (data, elements, model, queryColumns) => {
  // check all columns
  for (let i = 0, length = queryColumns.length; i < length; i++) {
    const col = queryColumns[i]
    if (elements[col] && _isToConvert(elements[col].type)) {
      const dataArray = Array.isArray(data[0]) ? data : [data]
      for (const d of dataArray) {
        const elementValue = d[i]
        if (elementValue != null && elementValue !== '$now') {
          d[i] = _convertDateTimeElement(elementValue, elements[col])
        }
      }
    }
  }
}

/**
 * This method finds and converts the cds.DateTime and cds.Timestamp types to UTC.
 * HANA stores date time values without timezone
 * @param req - cds.Request
 * @returns {undefined}
 */
const convert = function (req, model) {
  if (typeof req.query === 'string' || !req.target) return
  if (
    !req.data ||
    (Array.isArray(req.data) && req.data.length === 0) ||
    (typeof req.data === 'object' && Object.keys(req.data).length === 0)
  ) {
    // > nothing to convert (e.g., in case of insert as select)
    return
  }

  // for recursion
  if (!model) model = this.model
  let elements = req.target.elements
  if (req.target._unresolved) {
    const activeName = req.target.name && ensureNoDraftsSuffix(req.target.name)
    if (model.definitions[activeName]) {
      elements = model.definitions[activeName].elements
    } else {
      return
    }
  }

  const data = Array.isArray(req.data) ? req.data : [req.data]
  if (req.query && req.query.INSERT && req.query.INSERT.columns) {
    _convertColumns(data, elements, model, req.query.INSERT.columns)
  } else {
    _convertEntries(data, elements, model)
  }
}

convert._initial = true

module.exports = convert
