const {createReadStream, createWriteStream, readFileSync, readFile:rf} = require ('./fs')
const readFile = require('util').promisify(rf)
const {Readable} = require('stream')

const SEPARATOR = /[,;\t]/
const CSV = module.exports = { read, parse, readHeader, stripComments, serialize }

function read (res) {
  try{
    return CSV.parse (readFileSync (res, 'utf-8'))
  } catch(e){/* ignore */}
}

function parse (csv) {
  if (csv[0] === BOM)  csv = csv.slice(1)
  let sep
  const lines = csv.split(/\s*\n/)
  const rows = [], headers = []
  for (let line of lines) {
    if (!rows.length && _ignoreLine (line))  continue
    if (!sep)  [sep] = SEPARATOR.exec(line)||[';']
    const values=[]; let val, currCol=0, c, inString=false
    for (let i=0; i<line.length; ) {
      c = line[i++]
      if (c === sep && !inString) {  // separator
        currCol++
        if (!rows.length && val !== undefined)  headers.push (currCol)     // skip column if header value is empty
        if (headers.includes(currCol))  values.push (_value4(val)) // skip value if column was skipped
        val = undefined //> start new val
      }
      else if (c === '"' && val === undefined) { // start quoted string
        val = ''
        inString = true
      }
      else if (c === '"' && inString) { // within quoted string
        if (line[i] === '"')  val += line[i++]  // escape quote:  "" > "
        else inString = false // stop string
      }
      else {  // normal char
        if (val === undefined)  val = ''
        val += c === '\\' ? '\\\\' : c
      }
    }
    // remaining value
    currCol++
    if (!rows.length && val !== undefined)  headers.push(currCol)  // skip column if header value is empty
    if ((val !== undefined || c === sep) && headers.includes(currCol))  values.push (_value4(val))
    if (values.length > 0)  rows.push (values)
  }
  return rows
}

function serialize (rows, columns, bom='\ufeff') {
  let csv = bom + ( columns || Object.keys(rows[0]) ).join(';') +"\n"
  for (let key in rows)  csv += `${key};${rows[key]}\r\n`
  return csv
}

async function readHeader (inStream, o={ignoreComments:true}) {
  let delimiter = ';'
  let cols = []
  let filtered = false
  await _filterLines (inStream, null, (line, stream) => {
    if (!cols.length) {
      if (o.ignoreComments && _ignoreLine(line)) {
        filtered = true
        return false
      }
      [delimiter] = SEPARATOR.exec(line)||[';']
      cols = line.split(delimiter) .map (each => each.trim()) .filter(each=>each.length)
      stream.close() // signal that we have seen enough
    }
    return true
  })
  return {cols, delimiter, filtered}
}

async function stripComments(file, outStream) {
  // most files don't need filtering, so do a quick check first
  const { filtered } = await readHeader(createReadStream(file))
  if (!filtered)  return false

  // buffer whole content so that we can write the out file
  const inStream = Readable.from([await readFile(file)])
  // clears the output file
  outStream = outStream || createWriteStream(file)
  let prelude = true
  await _filterLines (inStream, outStream, line => {
    if (prelude) {
      if (_ignoreLine(line))  return false
      prelude = false
    }
    // skip empty lines - HANA cannot handle them, e.g. at end of the file
    return line.trim().length > 0
  })
  return true
}

function _value4 (val) { //NOSONAR
  if (val)  val = val.trim()
  if (val === 'true') return true
  if (val === 'false') return false
  else return val
}

function _ignoreLine(line) {
  return line[0] === '#' || !line.trim().length
}

function _filterLines (input, out, filter) {
  return new Promise((resolve, reject)=> {
    const rl = require('readline').createInterface({input, crlfDelay: Infinity})
    const resumeOnDrain = () => rl.resume()
    let filtered = false
    rl.on ('line', line => {
      if (filter (line, rl)) {
        if (out && !out.write (line+'\n')) {
          rl.pause() // pause when writable signals so
          out.removeListener('drain', resumeOnDrain) // avoid too many listeners
          out.once('drain', resumeOnDrain)
        }
      }
      else filtered |= true
    })
    rl.on ('error', reject)
    rl.on ('close', () => out ? out.end() : resolve(filtered))
    if (out)  out.on('finish', () => resolve(filtered))
  })
}

const BOM = '\ufeff'
