const fs = require('@sap/cds-foss')('fs-extra')
const { BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_DEFAULT, OUTPUT_MODE_RESULT_ONLY } = require('./constants')
const { hasOptionValue, getProperty,relativePaths } = require('./util')

/**
 * The build task handler creates the build output for a dedicated build task type. It is uniquely identified by the build task's <code>use</code> property.
 * The build task engine will load the build task implementation using Nodejs require function. 
 * <p>
 * The build task engine protocol defines the following methods. The methods are invoked in descending order:
 * <ul>
 *  <li>init() - optional</li>
 *  <li> priority() - optional</li>
 *  <li>async prepare() - optional</li>
 *  <li>async clean()</li>
 *  <li>async build()</li>
 * </ul>
 * The build task handler provides several getters to access build context specific information, e.g. cds, env, task, logger...
 * A build task handler shall use its own build target folder in order to avoid conflicts with other build task handlers. 
 * Build tasks with identical priority are executed in prarallel. The
 */
class BuildTaskHandler {
    constructor(name, task, buildOptions) {
        if (!task.src && (!task.for || !task.use)) {
            throw new Error(`Invalid parameter build task - ${JSON.stringify(task)}`)
        }
        task.options = task.options || {}
        task.dest = task.dest || task.src

        this._name = name
        this._task = task
        this._buildOptions = buildOptions || {}
        this._written = new Set()
        this._messages = []
        this._buildOptions.for = this._buildOptions.for || {}
        this._buildOptions.for[task.for] = this._buildOptions.for[task.for] || {}
        this._buildOptions.outputMode = this._buildOptions.outputMode || OUTPUT_MODE_DEFAULT
    }

    /**
     * Returns the name of this build task.
     */
    get name() {
        return this._name;
    }
    /**
     * Returns the logger that has been passed the build task engine.
     */
    get logger() {
        return this._logger;
    }
    /**
     * Returns the cds module providing access to the CDS compiler functionality and other framework functionality.
     */
    get cds() {
        return this._cds
    }
    /**
     * Returns the effective CDS environment used by this CDS build execution.
     */
    get env() {
        return this._cds.env
    }
    /**
     * Returns the build task executed by this build task handler.
     */
    get task() {
        return this._task
    }
    /**
     * Returns the build options used for this CDS build execution
     */
    get buildOptions() {
        return this._buildOptions
    }
    /**
     * Returns the message object to add build task specific build messages. Severity 'info', 'warn', and 'error' are supported.
     * @see BuildMessage for further details.
     * @see BuildError for further details.
     */
    get messages() {
        return this._messages
    }
    /**
     * Returns the list of files written by this build task handler of current CDS build execution.
     */
    get files() {
        return [...this._written]
    }
    /**
     * Used by the framework to initialize the logger implementation.
     */
    set logger(logger) {
        this._logger = logger;
    }
    /**
     * Used by the framework to initialize the correct cds context.
     */
    set cds(cds) {
        this._cds = cds;
    }

    /**
     * Returns the priority of this handler as number, where 0 is default, positive number means higher
     * and negative number lower priority.
     * Build task handlers with higher priority value are executed before handlers with lower priority.
     * Use Number.MAX_VALUE or -Number.MAX_VALUE
     * @returns the priority for this handler as number
     */
    get priority() {
        return 0
    }

    /**
     * Called by the framework immediately after this instance has been created.
     * The instance has already been fully initialized.
     */
    init() { }

    /**
     * Called by the framework after {@link #init()}. Handlers may want to perform more elaborate preparation.
     * E.g. caching some pre-calculated data that can be used across multiple build tasks. This kind of data
     * has to be stored in the handler type specific buildOptions section.
     * @returns {Promise<boolean>} A value 'false' indicates that {@link #prepare()} will not be called for other instances
     * of this handler type.
     * True indicates that {@link #prepare()} will be called for other instances of this of this handler type.
     */
    async prepare() {
        // cancel subsequent prepare calls for other handlers of the same type by default
        return false
    }

    /**
     * Called by the framework to create the artefacts of this build task handler.
     */
    async build() { }

    /**
     * Called by the framework immediately before 'build' to delete any output created by this build task handler.
     * <p>
     * Note: The <code>BuildTaskEngine</code> is cleaning the common generation target folder if the build is 
     * executed in staging mode, e.g. build.target: "gen", 
     * </p>
     */
    async clean() {
        // the build results have already been deleted by the BuildTaskEngine if the build.target !== '.'
        // make sure that src is not a subfolder of dest
        if (this.buildOptions.root === this.buildOptions.target && this.task.src !== this.task.dest && !this._isSubDirectory(this.task.dest, this.task.src)) {
            await fs.remove(this.task.dest)
        }
    }

    /**
     * Asynchronously write the given content to a given file path.
     * If the file exists the content is replaced. If the file does not exist, a new file will be created.
     * The file name is stored in the list of files written by this build task handler.
     * @param {*} data - If data is of type object the JSON-stringified version is written.
     */
    write(data) {
        return {
            to: async (dest) => {
                if (!this._hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
                    this.pushFile(dest)
                    if (this._hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_DEFAULT)) {
                        await fs.outputFile(dest, typeof data === "object" ? JSON.stringify(data, null, 2) : data)
                    }
                }
            }
        }
    }

    /**
     * Copy a file or directory if the build task option 'outputMode' does not have the value 'resultOnly'. 
     * The directory can have contents.
     * <p>
     * Note: The file name is stored in the list of files written by this build task handler.
     * </p>
     * @param {*} source The source path of the file or directory to copy. 
     * @param {String} dest The target path.
     */
    copy(source) {
        return {
            to: async (dest) => {
                if (!this._hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
                    this.pushFile(dest)
                    if (this._hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_DEFAULT)) {
                        // symlinks are not dereferenced
                        await fs.copy(source, dest)
                    }
                    return dest
                }
            }
        }
    }

    /**
     * Appends the given fully qualified file path to the list of files that have been written by this build task handler.
     * @param {string} filePath
     */
    pushFile(filePath) {
        this._written.add(filePath)
    }

    /**
     * Returns a list of CDS model files defining the transitive closure of the CDS model based on the model options
     * defined for this build task.
     */
    resolveModel() {
        let model
        if (Array.isArray(this.task.options.model)) {
            if (this.task.options.model.length > 0) {
                model = this.task.options.model
            } else {
                model = this.task.src
            }
        } else {
            model = this.task.options.model || this.task.src
        }
        return this.cds.resolve(model, this.buildOptions)
    }

    /**
     * Creates a compact CSN model using this build task's model options. 
     */
    async loadModel() {
        const modelPaths = this.resolveModel()
        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log("[cds] - no model found, skip build")
            return null
        }
        if (process.env.DEBUG) {
            this.logger.log(`[cds] - model: ${relativePaths(this.buildOptions.root, modelPaths).join(", ")}`)
        }
        const options = { messages: this._messages }
        // $location as well as @source paths are relative to current working dir by default
        // @source is required for custom handler resolution if serving the model from csn.json
        // identical base path required as CompilationErrors are compared based on location
        options.cwd = this.buildOptions.target === this.buildOptions.root ? this.task.src : this.buildOptions.root

        return this.cds.load(modelPaths, options)
    }

    // Determines whether the given build option value has been set for this build task.
    // If the value is omitted, the existence of the given property name is checked.
    _hasBuildOption(qualifiedName, value) {
        return hasOptionValue(this._getBuildOption(qualifiedName), value)
    }

    // Returns the value of the given build option defined for this build task.
    _getBuildOption(qualifiedName) {
        // build task options overwriting other settings
        let value = getProperty(this.task.options, qualifiedName)
        if (value !== undefined) {
            return value
        }
        value = getProperty(this.buildOptions.for[this.task.for], qualifiedName)
        if (value !== undefined) {
            return value
        }
        return getProperty(this.buildOptions, qualifiedName)
    }
}
module.exports = BuildTaskHandler
