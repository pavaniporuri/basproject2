module.exports = Object.assign ( _serve, {
    options: [
        '--service', '--from', '--to', '--at', '--with',
        '--port',
    ],
    flags: [
        '--project', '--projects',
        '--in-memory', '--in-memory?',
        '--mocked', '--with-mocks', '--with-bindings',
        '--watch',
    ],
    shortcuts: [ '-s', undefined, '-2', '-a', '-w', '-p' ],
    help: `
# SYNOPSIS

    *cds serve* [ <filenames> ] [ <options> ]
    *cds serve* [  <service>  ] [ <options> ]

    Starts http servers that load service definitions from cds models and
    construct service providers, mounted to respective endpoints to serve
    incoming requests.

    If the given argument refers to existing files, an effective model
    is loaded from these files and *all services*, that are served.
    The default is '*', which loads all models from the project.

    If the given argument doesn't match an existing file, it's used
    as the name of the *single service* to serve.


# OPTIONS


    *-s | --service* <name>  (default: 'all')

        Serve a _single service_ from specified model(s).
        EXAMPLE: *cds serve --service CatalogService*

    *-f | --from* <model>    (default: '*')

        Load service definitions from specified folder(s).
        EXAMPLE: *cds serve --from srv*

    *-w | --with* <impl>

        Define which implementation to use (i.e. a _.js_ file).
        EXAMPLE: *cds serve --service CatalogService --with srv/cat-service.js*

    *-a | --at* <endpoint>

        Add endpoint to bind the service to.
        EXAMPLE: *cds serve --at localhost:3030*

    *-2 | --to* <protocol>

        Decide on the protocol (i.e. _fiori_, _odata_, or _rest_) to serve.
        EXAMPLE: *cds serve --to odata*

    *-p | --project* [<project>]

        Runs _cds serve all_ for the specified project; default: cwd.
        You can use *cds run* as shortcut.

    *--port* <number>

        Specify the port on which the launched server shall listen.
        If you specify '0', the server picks a random free port.
        Alternatively, specify the port using env variable _PORT_.

    *--watch* [<project>]

        Like *--project* but starts through _nodemon_ to restart the server
        upon changes in code or models.
        You can use *cds watch* as shortcut, which is equivalent to:
        *cds serve --with-mocks --in-memory? --watch --project ...*

    *--mocked*

        Use this option to launch a _single service_  in a mock server, for
        a model you imported from an external source, like an S/4 system,.
        In addition to constructing the service provider, this will bootstrap
        a transient _in-memory_ database, filled with tables corresponding
        to the signatures of the service's exposed entities.

    *--with-mocks*

        Use this in combination with the variants serving _multiple services_.
        It starts in-process mock services for all required services configured
        in _package.json#cds.requires_, which don't have external bindings
        in the current process environment.
        Note that by default, this feature is disabled in production and must be
        enabled with configuration 'features.mocked_bindings=true'.

    *--with-bindings*

        Use this option in local tests, to have all services provided by a
        process registered with their physical urls in a temporary file.
        All required services are bound automatically upon bootstrapping.
        Option *--with-mocks* subsumes this option.

    *--in-memory[?]*

        Automatically adds a transient in-memory database bootstrapped on
        each (re-)start in the same way *cds deploy* would do, based on defaults
        or configuration in _package.json#cds.requires.db_. Add a question
        mark to apply a more defensive variant which respects the configured
        database, if any, and only adds an in-memory database if no
        persistent one is configured.

        Requires an sqlite driver to be installed. For example: _npm i sqlite3_.

# EXAMPLES

    *cds serve*
    *cds serve* all
    *cds serve* CatalogService *--from* app/
    *cds serve* CatalogService *--from* srv/ *--at* /cats *--to* rest
    *cds serve* all --watch --with-mocks --in-memory?
    *cds run* some/project
    *cds watch* some/project
    *cds watch*

`})


const {existsSync:exists} = require ('fs')
const {dirname,resolve} = require ('path')

async function _serve (...args) {
    try {
        await serve (...args)
        if (!global.cds.service.providers.length) _failed(
            `No service definitions found in loaded models`
        )
    } catch (e) {
        if (e.code === 'MODEL_NOT_FOUND') _failed(
            `No models found in ${global.cds.resolve(e.model||'*',false)}.`
        )
        else if (e.code === 'EADDRINUSE' && process.send)
            process.send (e)  // tell the calling process about it, e.g. cds watch
        else throw e
    }
    function _failed (msg) {
        if (serve.watch) {
            process.stderr.write (`\n    ${msg}\n`)
            process.stderr.write ('    Waiting for some to arrive...\n\n')
        } else {
            throw new Error (`${msg}\n`)
        }
    }
}


/**
 * The main function which dispatches into the respective usage variants.
 * @param {string[]} all - project folder, model filenames, or service name
 */
async function serve (all=[], o={}) { // NOSONAR

    // canonicalize options to ease subsequent tasks...
    const [pms] = all // project folder, model filenames, or service name
    if (o.from)                o.from = o.from.split(',')
    if (o.project||o.projects) { o.project = pms; o.service='all'; o.from='*' }
    else if (o.service)        { o.from    = pms ? pms.split(',') : '*'}
    else if (o.from)           { o.service = pms }
    else if (exists(pms))      { o.service ='all', o.from = all }
    else                       { o.service = pms,  o.from = '*' }
    if (!o.mocked)             { o.mocked  = o['with-mocks'] }

    // handle --watch and --project
    if (o.watch)  return _watch (o.project,o)   // cds serve --watch <project>
    if (o.project) _in_project (o.project)      // cds run --project <project>

    // IMPORTANT: never load any @sap/cds modules before the chdir above happened!
    const cds = _prepare_cds (o,require('../lib'))

    // The following things are meant for dev mode, which can be overruled by feature flagse...
    const {features} = cds.env
    {
        // load service bindings when mocking or asked to
        if (features.mocked_bindings && o.mocked || o['with-bindings']) await cds.service.bindings

        // handle --in-memory resp. --in-memory? (requires cds.env)
        if (features.in_memory_db) o.in_memory = _in_memory (o,cds.env)

        // add dev helper for Fiori URLs
        if (features.fiori_routes) require('../app/fiori/routes')

        // add fiori preview links to default index.html
        if (features.fiori_preview) require('../app/fiori/preview')
    }

    // bootstrap server from project-local server.js or from @sap/cds/server.js
    const server_js = _local('server.js') || _local(cds.env.folders.srv,'server.js') || cds.server
    const server = await server_js(o)

    // synchronize with the server events
    return new Promise((resolve, reject) => {
        server.listening ? done() : server.once('listening',done)
        server.on ('error', e => reject(e)) // startup errors like EADDRINUSE
        function done () {
            cds.emit ('listening', { server, url: `http://localhost:${server.address().port}` })
            resolve (server)
        }
    })
}


/** @param {import('../lib')} cds */
function _prepare_cds (o,cds) { // NOSONAR

    const cds_requires = Object.create(cds.requires)
    for (let entry of Object.values(cds.requires)) {
      if (entry.service)  cds_requires [entry.service] = entry
    }
    const cwd = process.env._original_cwd || process.cwd()
    const {relative} = require('path'), _relative = file => relative (cwd,file)
    const _timer = '\n[cds] - launched in'
    console.time (_timer)
    console.log()

    const _watched = serve.watch = cds.watch || process.env._cds_watch
    if (_watched) cds.once('connect', ()=>{
        console.log ('[cds] - using bindings from:', { registry: cds.service.bindings.registry })
    })

    // print information when model is loaded
    cds.on ('loaded', (model)=>{
        const all = model._sources.map (_relative)
        console.log (`[cds] - model loaded from ${all.length} file(s):\n\x1b[2m`)
        for (let each of all)  console.log (' ', each)
        console.log ('\x1b[0m')
        if (o.mocked) require('../lib/db/deploy').include_external_entities_in(model)
    })

    // print information about each connected service
    cds.on ('connect', ({name,kind,options:{use,credentials}})=>{
        console.log (`[cds] - connect to ${name} > ${use||kind}`, _redacted(credentials))
    })

    // print information about each provided service
    cds.on ('serving', ({name,path,options:o,_source = o.impl && o.impl._source}) => {
        const serving = name in cds_requires ? 'mocking' : 'serving'
        const details = { at:path }
        if (_source) details.impl = _relative(_source)
        console.log (`[cds] - ${serving} ${name}`, details)
    })

    // print info when we are finally on air
    cds.once ('listening', ({url})=>{
        console.timeEnd (_timer)
        console.log ('[cds] - server listening on', {url})
        if (_watched || process.stdin.isTTY)  console.log (`[ terminate with ^C ]\n`)
    })

    return cds
}


/** handles --watch option */
function _watch (project,o) {
    o.args = process.argv.slice(2) .filter (a => a !== '--watch' && a !== '-w')
    try { return require('@sap/cds-dk/bin/watch')([project],o) }
    catch (e) { if (e.code !== 'MODULE_NOT_FOUND')  throw e }
    console.error (`
    cds run --watch has moved.  Please install '@sap/cds-dk' and use
    'cds watch' instead as follows:

        npm uninstall -g @sap/cds
        npm install   -g @sap/cds-dk

        cds watch
    `)
}


/** handles --project option */
function _in_project (project) {
    // save the former process.cwd()
    const former = process.env._original_cwd = process.cwd()
    try { // using the given project as dirname, e.g. './bookshop'
        process.chdir (project)
    } catch(e) {
        try { // using the given project as a node package name, e.g. '@capire/bookshop'
            process.chdir (dirname (require.resolve(project+'/package.json')))
        } catch(_){ throw e }
    }
    // restore the former process.cwd()
    process.on('exit', ()=> process.chdir (former))
}


/** handles --in-memory option */
function _in_memory (o,env) {
    const db = env.requires.db
    if (o['in-memory'] || o['in-memory?'] && !db) {
        env.add ({ requires: { db: {
            kind:'sqlite', ...env.requires.sqlite,
            credentials:{database:':memory:'}
        }}})
        return true
    }
    if (db && db.credentials && db.credentials.database === ':memory:') {
        return true
    }
}


/** used to load local server.js */
function _local (...path) {
    const file = resolve(...path)
    if (exists(file)) return require (file)
}


/** mascades password-like strings, also reducing clutter in output */
function _redacted (cred) {
    const secrets = /(password)|(certificate)|(ca)/i // 'certificate' and 'ca' on HANA
    const newCred = Object.assign({}, cred)
    Object.keys (newCred)
        .filter (k => typeof newCred[k] === 'string' && secrets.test(k))
        .forEach (k => newCred[k] = '...')
    return newCred
}

/* eslint no-console:off */
