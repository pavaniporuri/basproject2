'use strict';

const { isArtifact, isContainerArtifact } = require('../model/modelUtils');
const builtins = require('../compiler/builtins.js');
const alerts = require('../base/alerts');
const { getMessageFunction } = require('../base/messages');

// Check the annotation assignments (if any) of 'annotatable', possibly using annotation
// definitions from 'model'. Report errors on 'model.messages.
function checkAnnotationAssignments(annotatable, model) {
  const { warning, signal } = alerts(model);
  const message = getMessageFunction(model);

  // Iterate all annotations of 'annotatable'
  Object.keys(annotatable).filter(a => a.startsWith('@')).forEach(a => {
    let anno = annotatable[a];

    // Sanity checks (ignore broken assignments)
    if (!anno.name || !anno.name.path) {
      return;
      // throw new Error('Expecting annotation assignment to have a name with a path: ' + JSON.stringify(anno));
    }

    // Artifact for first path step of annotation path has been provided by compiler if found
    let fromArtifact = anno.name.path[0]._artifact;
    if (!fromArtifact) {
      // Unchecked annotation, because not even the first path step was resolvable => nothing to check
      return;
    }
    // Resolve manually
    // FIXME: This will probably be done by the compiler some day
    // Note: Even if we just got an _artifact here, it might (depending on processing order) be an incomplete
    // one (at the time it is attached to the annotation, it might just be a USING, and currently this is not
    // really 'resolved' by the compiler for annotation assignments). The only thing the artifact is
    // guaranteed to already have is an absolute name. So we go and look that up in 'definitions' before using it.
    fromArtifact = model.definitions[fromArtifact.name.absolute];
    let { artifact, endOfPath } = resolvePathFrom(anno.name.path.slice(1), fromArtifact);

    // Check what we actually want to check
    checkAnnotationAssignment(anno, artifact, endOfPath);
  });

  // Perform checks for annotation assignment 'anno', using corresponding annotation declaration,
  // made of 'annoDecl' (artifact or undefined) and 'elementDecl' (annotation or element
  // or undefined). Report errors on 'model.messages.
  function checkAnnotationAssignment(anno, annoDecl, elementDecl) {
    // Nothing to check if no actual annotation declaration was found
    if (!annoDecl || (isContainerArtifact(annoDecl) && !elementDecl)) {
      return;
    }

    // The annotation resolution will change in v2: Only absolute paths are allowed.
    // To make the upgrade easier, warn for cases where a non-absolute path is used.
    // Note that we cannot simply compare the first path segment or we would miss cases like:
    //
    //   namespace test;
    //   annotation test { test: { str: String; } }
    //   @test.test.str: 'test'
    //   entity E { ... }
    //
    // We also cannot _always_ compare `artifactInV1` with `artifactInV2` as the path may
    // be absolute and `path[0]` may refer to an USING, e.g.
    //
    //   namespace ns;
    //   annotation test { str: String; }
    //   @(ns.test.str: 'some string') // path[0]._artifact !== xsn.definitions['ns']
    //   entity SomeEntity { key id : String; }
    //
    // So only if the first path segment resolves to an annotation, we check if the
    // representation changes.  Or if the first path segment refers to a (temporary)
    // namespace, e.g. for:
    //
    //   namespace test.test;
    //   annotation test.SecondLevelAnnotation { int: Integer; }
    //   @(test.SecondLevelAnnotation.int: 42)
    //   entity OtherEntity { key id : String; }
    //
    // The example above could be replaced by an absolute path
    const oldName = anno.name.path[0].id;
    const artifactInV1 = anno.name.path[0]._artifact;
    const artifactInV2 = model.definitions[oldName];
    if (artifactInV1.kind !== 'using' && artifactInV1 !== artifactInV2) {
      const loc = anno.name.path[0].location || anno.name.location;
      const canBeReplaced = !(annoDecl.name.absolute.startsWith(oldName));
      // The used annotation path in the CDS source.
      let oldFullName = anno.name.path.map(step => step && step.id).join('.');
      // Remove the element path because we only check for definition resolution.
      // Note that elementDecl may be an entity or other artifact at this stage.
      if (elementDecl && elementDecl.name.element) {
        const elementSuffix = elementDecl.name.element.length;
        oldFullName = oldFullName.slice(0, oldFullName.length - elementSuffix - 1);
      }
      message('anno-name-resolution', loc, annotatable,
        {
          '#': canBeReplaced ? 'replace' : 'std',
          anno: oldFullName,
          alias: '@' + annoDecl.name.absolute
        }, 'Warning',
        {
          std: 'The annotation $(ALIAS), not $(ANNO) is used with cds-compiler v1.x',
          replace: 'The annotation $(ALIAS), not $(ANNO) is used with cds-compiler v1.x; replace the annotation accordingly if this is really intended'
        }
      );
    }

    // Must be an annotation if found
    if (annoDecl.kind !== 'annotation') {
      // no warning anymore => behavior changes in v2
      return;
    }

    // Element must exist in annotation
    if (!elementDecl) {
      signal(warning`Element "${anno.name.path.map(step => step.id).join('.')}" not found for annotation "${annoDecl.name.absolute}"`, anno.location || anno.name.location);
      return;
    }

    // Sanity checks
    if (!elementDecl._finalType) {
      throw new Error('Expecting annotation declaration to have _finalType: ' + JSON.stringify(annoDecl));
    }

    // Must have literal or path unless it is a boolean
    if (!anno.literal && !anno.path && getFinalTypeNameOf(elementDecl) !== 'cds.Boolean') {
      if (elementDecl.type && elementDecl.type._artifact.name.absolute) {
        signal(warning`Expecting a value of type "${elementDecl.type._artifact.name.absolute}" for the annotation`, anno.location || anno.name.location);
      } else {
        signal(warning`Expecting a value for the annotation`, anno.location || anno.name.location);
      }
      return;
    }

    // Value must be assignable to type
    checkValueAssignableTo(anno, elementDecl);
  }

  // Check that annotation assignment 'value' (having 'path or 'literal' and 'val') is potentially assignable
  // to element 'element'. Complain on 'loc' if not
  function checkValueAssignableTo(value, elementDecl) {
    // FIXME: We currently do not have any element declaration that could match a 'path' value, so we simply
    // leave those alone
    if (value.path) {
      return;
    }

    // Array expected?
    if (elementDecl._finalType.items) {
      // Make sure we have an array value
      if (value.literal !== 'array') {
        signal(warning`An array value is required here`, value.location || value.name.location);
        return;
      }
      // Check each element
      for (let valueItem of value.val) {
        checkValueAssignableTo(valueItem, elementDecl._finalType.items);
      }
      return;
    }

    // Struct expected (can only happen within arrays)?
    if (elementDecl._finalType.elements) {
      if (value.literal !== 'struct') {
        signal(warning`A struct value is required here`, value.location || value.name.location);
        return;
      }
      // FIXME: Should check each element
      return;
    }

    // Handle each (primitive) expected element type separately
    let type = getFinalTypeNameOf(elementDecl);
    if (builtins.isStringTypeName(type)) {
      if (value.literal !== 'string' && value.literal !== 'enum' && !elementDecl._finalType.enum) {
        signal(warning`A string value is required for type "${type}"`, value.location || value.name.location);
      }
    } else if (builtins.isBinaryTypeName(type)) {
      if (value.literal !== 'string' && value.literal !== 'hex') {
        signal(warning`A hexadecimal string value is required for type "${type}"`, value.location || value.name.location);
      }
    } else if (builtins.isNumericTypeName(type)) {
      if (value.literal !== 'number' && value.literal !== 'enum' && !elementDecl._finalType.enum) {
        signal(warning`A numerical value is required for type "${type}"`, value.location || value.name.location);
      }
    } else if (builtins.isDateOrTimeTypeName(type)) {
      if (value.literal !== 'date' && value.literal !== 'time' && value.literal !== 'timestamp' && value.literal !== 'string') {
        signal(warning`A date/time value or a string is required for type "${type}"`, value.location || value.name.location);
      }
    } else if (builtins.isBooleanTypeName(type)) {
      if (value.literal && value.literal !== 'boolean') {
        signal(warning`A boolean value is required for type "${type}"`, value.location || value.name.location);
      }
    } else if(builtins.isRelationTypeName(type) || builtins.isGeoTypeName(type)) {
      signal(warning`Type "${type}" cannot be assigned a value`, value.location || value.name.location);
    } else {
      throw new Error('Unknown primitive type name: ' + type);
    }

    // Check enums
    let expectedEnum = elementDecl._finalType.enum;
    if (value.literal === 'enum') {
      if (expectedEnum) {
        // Enum symbol provided and expected
        if (!expectedEnum[value.symbol.id]) {
          // .. but no such constant
          signal(warning`Enum symbol "#${value.symbol.id}" not found in enum`, value.location || value.name.location);
        }
      } else {
        // Enum symbol provided but not expected
        signal(warning`Cannot use enum symbol "#${value.symbol.id}" for non-enum type "${type}"`, value.location || value.name.location);
      }
    } else {
      if (expectedEnum) {
        // Enum symbol not provided but expected
        if (!Object.keys(expectedEnum).some(symbol => expectedEnum[symbol].value.val == value.val)) {
          // ... and none of the valid enum symbols matches the value
          signal(warning`An enum value is required here`, value.location || value.name.location);
        }
      }
    }
  }

  // Return the artifact (and possibly, its element) found by following 'path' starting at 'from'.
  // The return value is an object { artifact, endOfPath } with 'artifact' being the last artifact
  // encountered on 'path' (or 'undefined' if none found), and 'endOfPath' being the element or artifact
  // represented by the full path (or 'undefined' if not found).
  // Note that only elements and artifacts are considered for path traversal (no actions, functions,
  // parameters etc.)
  function resolvePathFrom(path, from, result = {}) {
    // Keep last encountered artifacts
    if (isArtifact(from)) {
      result.artifact = from;
    }
    // Always keep current path end
    result.endOfPath = from;
    // Stop if found or failed
    if (path.length === 0 || !from) {
      return result;
    }
    // Continue search with next path step
    let nextStepEnv = (from._finalType || from).artifacts || from._finalType.elements || [];
    return resolvePathFrom(path.slice(1), nextStepEnv[path[0].id], result);
  }

  // Return the absolute name of the final type of 'node'. May return 'undefined' for
  // anonymous types
  function getFinalTypeNameOf(node) {
    let type = node._finalType;
    if (type.type)
      type = type.type._artifact;
    return type && type.name && type.name.absolute;
  }
}

module.exports = checkAnnotationAssignments;
