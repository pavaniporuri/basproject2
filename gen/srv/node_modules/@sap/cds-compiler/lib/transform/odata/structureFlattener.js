'use strict';

const { copyAnnotations } = require('../../model/modelUtils');
const { setProp } = require('../../base/model');
const { cloneCsn, forEachDefinition } = require('../../model/csnUtils');

// these functions are used for propagation of the annotations, collected along the path during flattening
const { addAnnotationsForPropagationFromElement, propagateAnnotationsToElement, resetAnnotationsForRropagation } = function () {
  let toBePropagatedAnnotations = Object.create(null);
  return {
    addAnnotationsForPropagationFromElement: function (element) {
      copyAnnotations(element, toBePropagatedAnnotations);
    },
    propagateAnnotationsToElement: function (element) {
      copyAnnotations(toBePropagatedAnnotations, element);
    },
    resetAnnotationsForRropagation: function () {
      toBePropagatedAnnotations = Object.create(null);
    }
  }
}();

// keep here the state of the 'notNull' attribute
// this is needed because during flattening all the elements
// along the chain need to be assigned with not null so
// the resulting element to be not null as well
const { isNotNull, setNotNull, setUpNotNull } = function () {
  let notNull = undefined;
  return {
    isNotNull: function () {
      return notNull;
    },
    setNotNull: function (value) {
      notNull = value;
    },
    setUpNotNull: function (element, isParentNotNull) {
      if (isParentNotNull && element.notNull) setNotNull(element.notNull);
      else if (isNotNull() && !element.notNull || (isNotNull() === false && element.notNull !== false)) setNotNull(undefined);
    }
  }
}();

/**
 * During the OData transformations in flat-mode, all structured elements will be flattened.
 * This module performs the complete flattening.
 * It also provides information to the reference flattener: elements produced for specific path in the CSN structure.
 * Each generated element gets hidden attributes:
 *  - $viaTransform - states that the element was generated during transformation
 *  - _flatElementNameWithDots - names in the element path concatenated with dot
 * @param {*} csn CSN-object to flatten
 * @param {*} csnUtils instances of utility functions
 */

function flattenCSN(csn, csnUtils, referenceFlattener, signal) {
  forEachDefinition(csn, (def, defName, propertyName, path) =>
    flattenDefinition(def, path, csnUtils, referenceFlattener, signal));
}

/**
 * Flattens one single definition and all structures in it. Modifies the definition in place.
 * @param {*} definition definition object to flatten
 * @param {*} definitionPath path in CSN object
 * @param {*} csnUtils utility functions
 */
function flattenDefinition(definition, definitionPath, csnUtils, referenceFlattener, signal) {
  if (definition.kind !== 'entity' && definition.kind !== 'view') return;

  let { newFlatElements } = flattenStructure(definition, definitionPath, csnUtils, signal, referenceFlattener);

  referenceFlattener.attachPaths(newFlatElements, definitionPath.concat('elements'));

  definition.elements = newFlatElements;
} // flattenDefinition

/**
 * Flattenes structured element by calling element flattener for each structured child.
 * Returns a dictionary containing all the new elements for the given structure.
 * @param {*} struct the structure to flatten
 * @param {*} path the path of the structure in the CSN tree
 * @param {*} isTopLevelElement states if this is a top level element
 * @param {*} elementPathInStructure list of parent element names
 * @param {*} isKey true if this or the parent element is a key - will be propagated to all child elements
 */
function flattenStructure(struct, path, csnUtils, error, referenceFlattener = undefined, elementPathInStructure = [],
  newFlatElements = Object.create(null), isTopLevelElement = true, isKey = false, propagateAnnotations = false, isParentNotNull = false) {

  isTopLevelElement ? resetAnnotationsForRropagation() : addAnnotationsForPropagationFromElement(struct);

  let generatedNewFlatElementsNames = []; // holds the names of all new child elements of the structure

  for (let elementName in struct.elements) {
    let element = struct.elements[elementName];
    let currPath = path.concat('elements', elementName);

    if (isTopLevelElement) {
      isKey = element.key;
      setNotNull(element.notNull)
    } else {
      setUpNotNull(element, isParentNotNull);
    }

    // flat elements when structured and NOT empty (allow incomplete structures - cds-compiler#4337)
    if (csnUtils.isStructured(element) && !(element.elements && Object.keys(element.elements).length === 0)) {

      if (referenceFlattener) referenceFlattener.registerFlattenedElement(currPath, element.$path);

      addAnnotationsForPropagationFromElement(element);

      // if the child element is structured itself -> needs to be flattened
      const subStruct = element.elements ? element : csnUtils.getFinalBaseType(element.type);
      let result = flattenStructure(subStruct, currPath, csnUtils, error, referenceFlattener, elementPathInStructure.concat(elementName), newFlatElements, false, isKey || element.key, true, isNotNull());
      generatedNewFlatElementsNames.push(...result.generatedNewFlatElementsNames); // accomulate names of produced elements

    } else { // when we do not need to flat, this is scalar or empty (cds-compiler#4337) -> needs to be registered in referenceFlattener
      let newElementName = elementPathInStructure.concat(elementName).join('_');
      let elementNameWithDots = elementPathInStructure.concat(elementName).join('.');
      addNewElementToResult(element, newElementName, elementNameWithDots, currPath);
    }

  }

  if (referenceFlattener) {
    referenceFlattener.registerGeneratedElementsForPath(path, generatedNewFlatElementsNames);
  }
  return { newFlatElements, generatedNewFlatElementsNames };


  // adds newly created element into the final dictionary of elements
  function addNewElementToResult(element, elementName, elementNameWithDots, path) {
    if (newFlatElements[elementName]) {
      error(null, path, `Generated element ${elementName} conflicts with other generated element`);
    } else {
      let newElement = createNewElement(element, elementNameWithDots);
      newFlatElements[elementName] = newElement;
      generatedNewFlatElementsNames.push(elementName);

      if (referenceFlattener) {
        let newPath = path.slice(0, 2).concat('elements', elementName);
        referenceFlattener.registerElementTransition(path, newPath);
        let movedTo = referenceFlattener.getElementTransition(path)
        if (movedTo) {
          setProp(newElement, '$paths', [movedTo]); // moved always on top-level -> new $paths has only one path element
        }
      }
    }
  } // addNewElementToResult

  // creates new element by copying the properties of the originating element
  function createNewElement(element, elementNameWithDots) {
    let newElement = cloneCsn(element);
    if (propagateAnnotations) propagateAnnotationsToElement(newElement);
    if (isNotNull() === undefined) delete newElement.notNull;
    if (isKey) newElement.key = true;
    if (!isTopLevelElement) {
      setProp(newElement, '$viaTransform', true);
      setProp(newElement, '_flatElementNameWithDots', elementNameWithDots);
    }
    return newElement;
  } // createNewElement

} // flattenStructure

module.exports = { flattenCSN, flattenStructure };
