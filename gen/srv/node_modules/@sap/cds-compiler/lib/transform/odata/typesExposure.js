'use strict';

/**
 * In this module resides all the logic related to exposure of types as part of the OData backend
 * @module typesExposure
 */

const { setProp, isBetaEnabled } = require('../../base/model');
const { defNameWithoutServiceName, getServiceOfArtifact, isArtifactInService, isArtifactInSomeService } = require('./utils');
const { cloneCsn, isBuiltinType, forEachDefinition, forEachMember, forEachMemberRecursively } = require('../../model/csnUtils');
const { copyAnnotations } = require('../../model/modelUtils');

/**
 * @param {CSN.Model} csn
 * @param {string[]} services
 * @param {CSN.Options} options
 * @param {*} csnUtils
 * @param {object} message message object with { error } function
 * @param {*} referenceFlattener
 */

function typesExposure(csn, services, options, csnUtils, message, referenceFlattener = undefined) {
  const { error } = message;
  // are we working with structured OData or not
  const structuredOData = options.toOdata.odataFormat === 'structured' && options.toOdata.version === 'v4';
  // are we working with OData proxies or cross-service refs
  const isMultiSchema = structuredOData && (isBetaEnabled(options, 'odataProxies') && (options.toOdata.odataProxies || options.toOdata.odataXServiceRefs));
  // collect in this variable all the newly exposed types
  let exposedStructTypes = [];

  // walk through the definitions of the given CSN and expose types where needed
  forEachDefinition(csn, (def, defName, propertyName, path) => {
    // we do expose types only for definition from inside services
    if (isArtifactInSomeService(defName, services)) {
      let serviceName = getServiceOfArtifact(defName, services);

      if (def.kind === 'type') {
        forEachMember(def, (element, elementName, propertyName, path) => {
          if (propertyName === 'elements') {
            exposeStructTypeOf(element, `${defName}.${elementName}`, defName, getServiceOfArtifact(defName, services), `${isMultiSchema ? defName : defName.replace(/\./g, '_')}_${elementName}`, structuredOData, path);
            // TODO: use the next line once the array of logic is reworked
            // exposeTypeOf(element, elementName, getServiceOfArtifact(defName, services), `${defName.replace(/\./g, '_')}_${elementName}`);
          }
        }, path);
      }

      // For exposed actions and functions that use non-exposed or anonymous structured types, create
      // artificial exposing types.
      // unbound actions
      if (def.kind === 'action' || def.kind === 'function') {
        exposeTypesOfAction(def, defName, defName, serviceName, path);
      }
      // bound actions
      for (let actionName in def.actions || {}) {
        exposeTypesOfAction(def.actions[actionName], `${defName}_${actionName}`, defName, serviceName, path.concat(['actions', actionName]));
      }

      if (def.kind === 'entity' || def.kind === 'view') {
        forEachMember(def, (element, elementName, propertyName, path) => {
          if (propertyName === 'elements') {
            if (csnUtils.isStructured(element)) {
              exposeStructTypeOf(element, elementName, defName, serviceName, `${isMultiSchema ? defNameWithoutServiceName(defName, serviceName) : defNameWithoutServiceName(defName, serviceName).replace(/\./g, '_')}_${elementName}`, structuredOData, path);
              // TODO: use the next line once the array of logic is reworked
              // exposeTypeOf(element, elementName, getServiceOfArtifact(defName, services), `${defName.replace(/\./g, '_')}_${elementName}`);
            }
            // TODO: there should be a better plaace for this check
            if (csnUtils.getServiceName(defName) && !element.type && !element.items && !element.elements) {
              error(null, path, `Element "${defName}.${elementName}" does not have a type: Elements of ODATA entities must have a type`);
            }
          }
        }, path);

        // Expose types for 'array of/many' declarations
        let isAction = false;
        // If a member is of type 'array of T' where T is either user defined structured type outside of the service or anonymous type,
        // then expose T and assign it do the member.
        forEachMemberRecursively(def, (member, memberName, prop, path) => {
          // we do apply array of exposure logic on actions/functions
          // and on params and returns of action/function always,
          // regardless of the OData version or format
          if (member.kind === 'action' || member.kind === 'function') isAction = true;

          if (isArrayed(member)) {
            if (structuredOData)
              exposeArrayOfTypeOf(member, memberName, defName, serviceName, `${defNameWithoutServiceName(defName, serviceName)}_${memberName}`, path);
            else if (options.toOdata.version === 'v4' && !isAction) {
              exposeArrayOfTypeOf(member, memberName, defName, serviceName, `${defNameWithoutServiceName(defName, serviceName)}_${memberName}`, path);
            }
          }
        }, path);
      }
    }
  });

  if (referenceFlattener)
    exposedStructTypes.forEach(typeName => referenceFlattener.attachPaths(csn.definitions[typeName], ['definitions', typeName]))

  // still WIP function
  function exposeTypeOf(node, memberName, defName, service, artificialName, path) {
    if (isArrayed(node))
      exposeArrayOfTypeOf(node, memberName, defName, service, artificialName, path);
    else
      exposeStructTypeOf(node, memberName, defName, service, artificialName, structuredOData, path);
  }

  // still WIP function
  function isArrayed(node) {
    return node.items || (node.type && csnUtils.getFinalTypeDef(node.type).items);
  }

  /**
   * If an 'action' uses structured types as parameters or return values that are not exposed in 'service'
   * (because the types are anonymous or have a definition outside of 'service'),
   * create equivalent types in 'service' and make 'action' use them instead,
   * @param {Object} action
   * @param {String} actionName
   * @param {String} service
   */
  function exposeTypesOfAction(action, actionName, defName, service, path) {
    if (action.returns)
      exposeTypeOf(action.returns, actionName, defName, service, `return_${actionName.replace(/\./g, '_')}`, path.concat(['returns']));

    for (let paramName in action.params || {}) {
      exposeTypeOf(action.params[paramName], actionName, defName, service, `param_${actionName.replace(/\./g, '_')}_${paramName}`, path.concat(['params', paramName]));
    }
  }

  /**
   * If 'node' exists and has a structured type that is not exposed in 'service', (because the type is anonymous or
   * has a definition outside of 'service'), create an equivalent type in 'service' and assign the new type
   * for a value of the 'node.type' property.
   * @param {Object} node
   * @param {String} memberName
   * @param {String} service
   * @param {String} artificialName
   */
  function exposeStructTypeOf(node, memberName, defName, service, artificialName, deleteElems = structuredOData, path, parentName) {
    if (!node) {
      // TODO: when node will be undefined, if node is undefined this should not be reached
      //console.log(parentName + ' --- ' + service + ' --- ' + artificialName);
      return;
    }

    // TODO: call exposure of Arrayed types?
    if (node.items) exposeStructTypeOf(node.items, memberName, defName, service, artificialName, deleteElems, path);

    if (isExposableStructure(node)) {
      let typeDef = node.type ? csnUtils.getCsnDef(node.type) : /* structure|anonymous type */ node;
      let newTypeId = node.type ? `${isMultiSchema ? node.type : node.type.replace(/\./g, '_')}` : artificialName;
      let newTypeFullName =
        isMultiSchema
          ? node.type ? getTypeNameInMultiSchema(node.type, service) : getAnonymousTypeNameInMultiSchema(artificialName, parentName || defName)
          : `${service}.${newTypeId}`;

      // With the redirection of sub elements, the element which is of named type with an association is now expanded and contains the association
      // and the new target. Consequently, we now have both type and elements properties in this case, and the elements should be taken as a priority
      // as the correct target is there and no longer in the type definition
      let newTypeElements = (node.type && node.elements) ? node.elements : typeDef.elements;

      let newType = exposeStructType(newTypeFullName, newTypeElements, memberName, path);
      if (!newType) {
        // Error already reported
        return;
      }

      if (node.$location) setProp(newType, '$location', node.$location);
      setProp(newType, '$exposedBy', 'typeExposure');

      // Recurse into elements of 'type' (if any) and expose them as well (is needed)
      for (let elemName in newType.elements) {
        if (node.elements && node.elements[elemName].$location) setProp(newType.elements[elemName], '$location', node.elements[elemName].$location);
        exposeStructTypeOf(newType.elements[elemName],
          memberName,
          typeDef.kind === 'type' ? node.type : defName,
          service,
          isMultiSchema ? `${newTypeFullName}_${elemName}` : `${newTypeId}_${elemName}`,
          deleteElems,
          path,
          newTypeFullName);
      }
      typeDef.kind === 'type' ? copyAnnotations(typeDef, newType) : copyAnnotations(node, newType);
      if (deleteElems) delete node.elements;
      node.type = newTypeFullName;
    }

    /**
     * Returns whether the 'node' is for exposing the in service.
     * There are 2 cases when we would like to expose a type is the service:
     *  1. If the node is of user-defined type which is not part of the service
     *  2. When we have structured element (the object has property 'elements')
     * @param {Object} node
     */
    function isExposableStructure(node) {
      let finalNodeType = node.type ? csnUtils.getFinalType(node.type) : undefined;
      return finalNodeType && isArtifactInService(finalNodeType, service)
        ? false
        : csnUtils.isStructured(node);
    }

    /**
     * Calculate the new type name that will be exposed in multi schema,
     * in case that the element has a named type.
     * 
     * @param {string} typeName type of the element
     * @param {string} service current service name
     */
    function getTypeNameInMultiSchema(typeName, service) {
      if (isArtifactInSomeService(typeName, services)) {
        const typeService = csnUtils.getServiceName(typeName);
        // new type name without any prefixes
        const typePlainName = defNameWithoutServiceName(typeName, typeService);
        const newContextName = `${service}.${typeService}`;
        createContext(newContextName);
        // return the new type name
        return `${newContextName}.${typePlainName.replace(/\./g, '_')}`;
      } else {
        const typeContext = csnUtils.getContextOfArtifact(typeName);
        const typeNamespace = csnUtils.getNamespaceOfArtifact(typeName);
        const newContextName = `${service}.${typeContext || typeNamespace || 'root'}`;
        // new type name without any prefixes
        const typePlainName = typeContext ? defNameWithoutServiceName(typeName, typeContext)
          : typeName.replace(`${typeNamespace}.`, '');
        createContext(newContextName);
        // return the new type name
        return `${newContextName}.${typePlainName.replace(/\./g, '_')}`;
      }
    }

    /**
     * Calculate the new type name that will be exposed in multi schema,
     * in case that the element has an anonymous type.
     * 
     * @param {string} typeName type of the element
     * @param {string} parentName name of the parent def holding the element
     */
    function getAnonymousTypeNameInMultiSchema(typeName, parentName) {
      let currPrefix = parentName.substring(0, parentName.lastIndexOf('.'));
      const newContextName = currPrefix || 'root';
      // new type name without any prefixes
      const typePlainName = defNameWithoutServiceName(typeName, newContextName);

      createContext(newContextName);
      return `${newContextName}.${typePlainName.replace(/\./g, '_')}`;
    }

    /**
     * Tf does not exists, create a context with the given name in the CSN
     * @param {string} newContextName 
     */
    function createContext(newContextName) {
      if (!csn.definitions[`${newContextName}`])
        csn.definitions[`${newContextName}`] = { kind: 'context' };
    }

    /**
     * Expose a new type definition in the 'definitions' of the CSN and return that type(reusing such a type
     * if it already exists).
     * The new type has name 'typeName', elements which are 'elements'.
     * 'parentName' is used for error reporting.x
     * @param {String} typeName
     * @param {Object} elements
     * @param {String} parentName
     */
    function exposeStructType(typeName, elements, parentName, path) {
      // If type already exists, reuse it (complain if not created here)
      let type = csn.definitions[typeName];
      if (type) {
        if (!exposedStructTypes.includes(typeName)) {
          error(null, path, `Cannot create artificial type "${typeName}" for "${parentName}" because the name is already used`);
          return null;
        }
        return type;
      }

      // Create a type with empty elements
      type = {
        kind: 'type',
        elements: Object.create(null),
      };

      // Duplicate the type's elements
      for (let elemName in elements) {
        if (type.elements[elemName]) {
          const path = ['definitions', typeName, 'elements', elemName];
          error(null, path, `"${elemName}": Element name conflicts with existing element`);
        }
        let cloned = cloneCsn(elements[elemName]);
        type.elements[elemName] = cloned;
      }

      // add to the CSN
      csn.definitions[typeName] = type;
      // store typeName in set of exposed struct types
      exposedStructTypes.push(typeName);
      return type;
    }
  }


  // If a member is of type "array of <named type|anonymous type>", we expose the arrayed type,
  // like we expose structures in structured mode
  function exposeArrayOfTypeOf(node, memberName, defName, service, artificialName, path) {
    // if anonymously defined in place -> we always expose the type
    // this would be definition like 'elem: array of { ... }'
    // and we use the artificial name for the new type name
    if (node.items && !node.type) {
      exposeStructTypeOf(node.items, memberName, defName, service, artificialName, true, path.concat('items'));
    }
    // we can have both of the 'type' and 'items' in the cases:
    // 1. 'elem: Foo' and 'type Foo: array of Baz' and 'type Baz: { ... }'
    // or 2. 'elem: Foo' and type Foo: array of Integer|String|...'
    else if (node.type) {
      // case 2. - in V2 we expand to the underlying base scalar and remove the type property
      if (node.items && node.items.type && isBuiltinType(node.items.type)
        && options.toOdata.version === 'v2') delete node.type;
      else if (csnUtils.getFinalTypeDef(node.type).items) {
        if (!isArtifactInService(node.type, service)) {
          let typeId = `${service}.${node.type.replace(/\./g, '_')}`;
          let newType = exposeArrayedType(node.items || csnUtils.getFinalTypeDef(node.type).items, typeId);
          // When we have in the model something like:
          // type Foo: array of Bar; type Bar: { qux: Integer };
          // In the type Foo we expand the first level of elements of the items like we have in CDL this:
          // type Foo: array of { qux: Integer };
          expandFirstLevelOfArrayed(newType);
          node.type = typeId;
        }
        // case 1. - as we keep the type property, the items property is removed
        if (node.items) delete node.items;
      }
    }

    function exposeArrayedType(items, typeId) {
      let newType = csn.definitions[typeId];
      if (newType) {
        if (!exposedStructTypes.includes(typeId)) {
          error(null, newType.$path, `Cannot create artificial type "${typeId}" because the name is already used`);
        }
        return newType;
      }
      // create empty type
      newType = {
        kind: 'type',
        items: Object.create(null),
      }

      // copy over the items
      newType.items = cloneCsn(items);
      csn.definitions[typeId] = newType;
      exposedStructTypes.push(typeId);
      return newType;
    }
  }

  // In case we have in the model something like:
  // type Foo: array of Bar; type Bar: { qux: Integer };
  // In the type Foo we expand the first level of elements of the items like we have in CDL this:
  // type Foo: array of { qux: Integer };
  function expandFirstLevelOfArrayed(def) {
    if (def.items.type && !isBuiltinType(def.items.type)) {
      let finalType = csnUtils.getFinalTypeDef(def.items.type);
      if (csnUtils.isStructured(finalType)) {
        if (!def.items.elements) def.items.elements = cloneCsn(finalType.elements);
        delete def.items.type;
      }
    }
  }
}

module.exports = typesExposure;
