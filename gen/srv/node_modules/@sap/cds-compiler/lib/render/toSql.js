
'use strict';

const { getTopLevelArtifactNameOf, getParentNameOf, getParentNamesOf, getLastPartOf, getLastPartOfRef } = require('../model/modelUtils');
const { hasBoolAnnotation, isBuiltinType } = require('../model/csnUtils');
const alerts = require('../base/alerts');
const version = require('../../package.json').version;
const { renderFunc } = require('./renderUtil');
const DuplicateChecker = require('./DuplicateChecker');
const { checkCSNVersion } = require('../json/csnVersion');
const { handleMessages } = require('../base/messages');
const timetrace = require('../utils/timetrace');
const { isBetaEnabled } = require('../base/model');
const { smartId, smartFuncId, delimitedId } = require('../sql-identifier');

// Type mapping from cds type names to DB type names:
// (in the future, we would introduce an option for the mapping table)
const cdsToSqlTypes = {
  standard: {
    // characters and binaries
    'cds.String': 'NVARCHAR',
    'cds.hana.NCHAR': 'NCHAR',
    'cds.LargeString' : 'NCLOB',
    'cds.hana.VARCHAR': 'VARCHAR',
    'cds.hana.CHAR': 'CHAR',
    'cds.hana.CLOB': 'CLOB',
    'cds.Binary': 'VARBINARY',  // not a Standard SQL type, but HANA and MS SQL Server
    'cds.hana.BINARY': 'BINARY',
    'cds.LargeBinary': 'BLOB',
    // numbers: exact and approximate
    'cds.Decimal': 'DECIMAL',
    'cds.DecimalFloat': 'DECIMAL',
    'cds.Integer64': 'BIGINT',
    'cds.Integer': 'INTEGER',
    'cds.hana.SMALLINT': 'SMALLINT',
    'cds.hana.TINYINT': 'TINYINT', // not a Standard SQL type
    'cds.Double': 'DOUBLE',
    'cds.hana.REAL': 'REAL',
    // other: date/time, boolean
    'cds.Date': 'DATE',
    'cds.Time': 'TIME',
    'cds.DateTime': 'TIMESTAMP', // cds-compiler#2758
    'cds.Timestamp': 'TIMESTAMP',
    'cds.Boolean': 'BOOLEAN',
    'cds.UUID': 'NVARCHAR',  // changed to cds.String earlier
    // (TODO: do it later; TODO: why not CHAR or at least VARCHAR?)
  },
  hana: {
    'cds.hana.SMALLDECIMAL': 'SMALLDECIMAL',
    'cds.DateTime': 'SECONDDATE',
    'cds.hana.ST_POINT': 'ST_POINT',
    'cds.hana.ST_GEOMETRY': 'ST_GEOMETRY',
  },
  sqlite: {
    'cds.Binary': 'CHAR',
    'cds.hana.BINARY': 'CHAR',
    'cds.hana.SMALLDECIMAL': 'DECIMAL',
  },
};

/**
 * Render the CSN model 'model' to SQL DDL statements. One statement is created
 * per top-level artifact into dictionaries 'hdbtable', 'hdbview', ..., without
 * leading CREATE, without trailing semicolon. All corresponding statements (in
 * proper order) are copied into dictionary 'sql', with trailing semicolon.
 * Also included in the result are dictionaries 'deletions' and 'migrations',
 * keyed by entity name, which reflect statements needed for deleting or changing
 * (migrating) entities.
 * In the case of 'deletions', each entry contains the corresponding DROP statement.
 * In the case of 'migrations', each entry is an array of objects representing
 * changes to the entity. Each change object contains one or more SQL statements
 * (concatenated to one string using \n) and information whether these incur
 * potential data loss.
 *
 * Return an object like this:
 * { "hdbtable": {
 *     "foo" : "COLUMN TABLE foo ...",
 *    },
 *   "hdbview": {
 *     "bar::wiz" : "VIEW \"bar::wiz\" AS SELECT \"x\" FROM ..."
 *   },
 *   "sql: {
 *     "foo" : "CREATE TABLE foo ...;\n",
 *     "bar::wiz" : "CREATE VIEW \"bar::wiz\" AS SELECT \"x\" FROM ...;\n"
 *   },
 *   "deletions": {
 *     "baz": "DROP TABLE baz"
 *   },
 *   "migrations": {
 *     "foo": [
 *       {
 *         "drop": false,
 *         "sql": "ALTER TABLE foo ALTER (elm DECIMAL(12, 9));"
 *       },
 *       {
 *         "drop": true,
 *         "sql": "ALTER TABLE foo DROP (eln);"
 *       },
 *       {
 *         "drop": false,
 *         "sql": "ALTER TABLE foo ADD (elt NVARCHAR(99));"
 *       }
 *     ]
 *   }
 * }
 *
 * @param {CSN.Model} csn
 * @param {object}    [options=csn.options]
 */
function toSqlDdl(csn, options = csn.options) {
  timetrace.start('SQL rendering');
  const { error, signal, warning, info } = alerts(csn, options);

  // Utils to render SQL statements.
  const render = {
    /*
      Render column additions as HANA SQL. Checks for duplicate elements.
      Only HANA SQL is currently supported.
     */
    addColumns: {
      fromElementStrings: function(tableName, eltStrings) {
        return [`ALTER TABLE ${tableName} ADD (${eltStrings.join(', ')});`];
      },
      fromElementsObj: function(artifactName, tableName, elementsObj, env, duplicateChecker) {
        // Only extend with 'ADD' for elements/associations
        // TODO: May also include 'RENAME' at a later stage
        const elements = Object.entries(elementsObj)
            .map(([name, elt]) => renderElement(artifactName, name, elt, duplicateChecker, null, env))
            .filter(s => s !== '');

        if (elements.length) {
          return render.addColumns.fromElementStrings(tableName, elements);
        }
        return [];
      }
    },
    /*
      Render association additions as HANA SQL.
      TODO duplicity check
     */
    addAssociations: function(artifactName, tableName, elementsObj, env) {
      return Object.entries(elementsObj)
          .map(([name, elt]) => renderAssociationElement(name, elt, env))
          .filter(s => s !== '')
          .map(eltStr => `ALTER TABLE ${tableName} ADD ASSOCIATION (${eltStr});`);
    },
    /*
      Render column removals as HANA SQL.
     */
    dropColumns: function(tableName, sqlIds) {
      return [`ALTER TABLE ${tableName} DROP (${sqlIds.join(', ')});`];
    },
    /*
      Render association removals as HANA SQL.
     */
    dropAssociation: function(tableName, sqlId) {
      return [`ALTER TABLE ${tableName} DROP ASSOCIATION ${sqlId};`];
    },
    /*
      Render column modifications as HANA SQL.
     */
    alterColumns: function (tableName, definitionsStr) {
      return [`ALTER TABLE ${tableName} ALTER (${definitionsStr});`];
    }
  };

  // FIXME: Currently requires 'options.forHana', because it can only render HANA-ish SQL dialect
  if (!options.forHana) {
    throw new Error('toSql can currently only be used with HANA preprocessing');
  }

  checkCSNVersion(csn, options);


  // Create artificial namespace objects, so that each artifact has parents up to top-level.
  // FIXME: This is actually only necessary to make 'getParentNameOf' work - should be reworked
  for (let artifactName in csn.definitions) {
    for (let parentName of getParentNamesOf(artifactName)) {
      if (!csn.definitions[parentName]) {
        csn.definitions[parentName] = {
          kind : 'namespace',
        };
      }
    }
  }

  // The final result in hdb-kind-specific form, without leading CREATE, without trailing newlines
  // (note that the order here is relevant for transmission into 'resultObj.sql' below and that
  // the attribute names must be the HDI plugin names for --src hdi)
  let resultObj = {
    hdbtabletype: Object.create(null),
    hdbtable: Object.create(null),
    hdbindex: Object.create(null),
    hdbfulltextindex: Object.create(null),
    hdbview: Object.create(null),
    deletions: Object.create(null),
    migrations: Object.create(null)
  }

  // Registries for artifact and element names per CSN section
  let definitionsDuplicateChecker = new DuplicateChecker();
  let deletionsDuplicateChecker = new DuplicateChecker();
  let extensionsDuplicateChecker = new DuplicateChecker();
  let removeElementsDuplicateChecker = new DuplicateChecker();
  let changeElementsDuplicateChecker = new DuplicateChecker();

  // Render each artifact on its own
  for (let artifactName in csn.definitions) {
    // This environment is passed down the call hierarchy, for dealing with
    // indentation issues
    const env = {
      // Current indentation string
      indent: '',
    };
    renderArtifactInto(artifactName, csn.definitions[artifactName], resultObj, env);
  }

  // Render each deleted artifact
  for (let artifactName in csn.deletions) {
    renderArtifactDeletionInto(artifactName, csn.deletions[artifactName], resultObj);
  }

  // Render each artifact extension
  // Only HANA SQL is currently supported.
  // Note that extensions may contain new elements referenced in migrations, thus should be compiled first.
  if (csn.extensions && options.toSql.dialect === 'hana') {
    for (const extension of csn.extensions) {
      if (extension.extend) {
        const artifactName = extension.extend;
        const env = { indent: '' };
        renderArtifactExtensionInto(artifactName, extension, resultObj, env);
      }
    }
  }

  // Render each artifact change
  // Only HANA SQL is currently supported.
  if (csn.migrations && options.toSql.dialect === 'hana') {
    for (const migration of csn.migrations) {
      if (migration.migrate) {
        const artifactName = migration.migrate;
        const env = { indent: '' };
        renderArtifactMigrationInto(artifactName, migration, resultObj, env);
      }
    }
  }

  // trigger artifact and element name checks
  definitionsDuplicateChecker.check(signal, error);
  extensionsDuplicateChecker.check(signal, error);
  deletionsDuplicateChecker.check(signal, error);

  // Throw exception in case of errors
  handleMessages(csn, options);

  // Transfer results from hdb-specific dictionaries into 'sql' dictionary in proper order if toSql.src === 'sql'
  // (relying on the order of dictionaries above)
  // FIXME: Should consider inter-view dependencies, too
  let sql = Object.create(null);
  let sqlVersionLine = `-- generated by cds-compiler version ${version}\n`;

  // Handle hdbKinds separately from alterTable case
  // eslint-disable-next-line no-unused-vars
  const { deletions, migrations, ...hdbKinds } = resultObj;
  for (let hdbKind of Object.keys(hdbKinds)) {
    for (let name in resultObj[hdbKind]) {
      if (options.toSql.src === 'sql') {
        let sourceString = resultObj[hdbKind][name];
        // Hack: Other than in 'hdbtable' files, in HANA SQL COLUMN is not mandatory but default.
        if (options.toSql.dialect === 'hana' && hdbKind === 'hdbtable' && sourceString.startsWith('COLUMN ')) {
          sourceString = sourceString.slice('COLUMN '.length);
        }
        sql[name] = `${options.testMode ? '' : sqlVersionLine}CREATE ${sourceString};`;
      }
      else {
        if (!options.testMode) {
          resultObj[hdbKind][name] = sqlVersionLine + resultObj[hdbKind][name];
        }
      }
    }
    if (options.toSql.src === 'sql') {
      delete resultObj[hdbKind];
    }
  }
  if (options.toSql.src === 'sql') {
    resultObj.sql = sql;
  }
  for (let name in deletions) {
    deletions[name] = `${options.testMode ? '' : sqlVersionLine}` + deletions[name];
  }

  timetrace.stop();
  return resultObj;


  // Render an artifact into the appropriate dictionary of 'resultObj'.
  function renderArtifactInto(artifactName, art, resultObj, env) {
    // Ignore whole artifacts if forHana says so
    if (art._ignore || hasBoolAnnotation(art, '@cds.persistence.exists', true)) {
      return;
    }
    switch (art.kind) {
      case 'entity':
      case 'view':
        if (art.query) {
          let result = renderView(artifactName, art, env);
          if (result) {
            resultObj.hdbview[artifactName] = result;
          }
        } else {
          renderEntityInto(artifactName, art, resultObj, env);
        }
        break;
      case 'type': {
        let result = renderType(artifactName, art, env);
        if (result) {
          resultObj.hdbview[artifactName] = result;
        }
        break;
      }
      case 'context':
      case 'service':
      case 'namespace':
      case 'annotation':
      case 'action':
      case 'function':
      case 'event':
        // Ignore: not SQL-relevant
        return;
      default:
        throw new Error('Unknown artifact kind: ' + art.kind);
    }
  }

  // Render an artifact deletion into the appropriate dictionary of 'resultObj'.
  function renderArtifactDeletionInto(artifactName, art, resultObj) {
    const tableName = quoteSqlId(absoluteCdsName(artifactName), art.$location);
    deletionsDuplicateChecker.addArtifact(tableName, art.$location, artifactName);

    addDeletion(resultObj, artifactName, `DROP TABLE ${tableName}`)
  }

  // Render an artifact extension into the appropriate dictionary of 'resultObj'.
  // Only HANA SQL is currently supported.
  function renderArtifactExtensionInto(artifactName, ext, resultObj, env) {
    // Property kind is always omitted for elements and can be omitted for
    // top-level type definitions, it does not exist for extensions.
    if (artifactName && !ext.query) {
      renderExtendInto(artifactName, ext.elements, resultObj, env, extensionsDuplicateChecker);
    }
    if (!artifactName) throw new Error('Undefined artifact name: ' + artifactName);
  }

  // Render an artifact migration into the appropriate dictionary of 'resultObj'.
  // Only HANA SQL is currently supported.
  function renderArtifactMigrationInto(artifactName, migration, resultObj, env) {
    function reducesTypeSize(def) {
      // HANA does not allow decreasing the value of any of those type parameters.
      return def.old.type === def.new.type &&
          ['length', 'precision', 'scale'].some(param => def.new[param] < def.old[param]);
    }
    function concat(...statements) {
      return [statements.join('\n')];
    }

    const tableName = quoteSqlId(absoluteCdsName(artifactName));

    // Drop column (unsupported in sqlite)
    if (migration.remove) {
      const entries = Object.entries(migration.remove);
      if (entries.length) {
        const removeCols = entries.filter(([, value]) => !value.target).map(([key, ]) => quoteSqlId(key));
        const removeAssocs = entries.filter(([, value]) => value.target).map(([key, ]) => quoteSqlId(key));

        removeElementsDuplicateChecker.addArtifact(tableName, undefined, artifactName);
        [...removeCols, ...removeAssocs].forEach(element => removeElementsDuplicateChecker.addElement(quoteSqlId(element), undefined, element));

        // Remove columns.
        if (removeCols.length) {
          addMigration(resultObj, artifactName, true, render.dropColumns(tableName, removeCols));
        }
        // Remove associations.
        removeAssocs.forEach(assoc => addMigration(resultObj, artifactName, true, render.dropAssociation(tableName, assoc)));
      }
    }

    // Change column type (unsupported in sqlite)
    if (migration.change) {
      changeElementsDuplicateChecker.addArtifact(tableName, undefined, artifactName)
      for (const [eltName, def] of Object.entries(migration.change)) {
        const sqlId = quoteSqlId(eltName);
        changeElementsDuplicateChecker.addElement(sqlId, undefined, eltName);
        if (options.sqlChangeMode === 'drop' || def.old.target || def.new.target || reducesTypeSize(def)) {
          // Lossy change because either an association is removed and/or added, or the type size is reduced.
          // Drop old element and re-add it in its new shape.
          const drop = def.old.target
              ? render.dropAssociation(tableName, sqlId)
              : render.dropColumns(tableName, [sqlId]);
          const add = def.new.target
              ? render.addAssociations(artifactName, tableName, {[eltName]: def.new}, env)
              : render.addColumns.fromElementsObj(artifactName, tableName, {[eltName]: def.new}, env);
          addMigration(resultObj, artifactName, true, concat(...drop, ...add));
        } else {
          // Lossless change: no associations directly affected, no size reduction.
          const eltStr = renderElement(artifactName, eltName, def.new, null, null, env);
          addMigration(resultObj, artifactName, false, render.alterColumns(tableName, eltStr));
        }
      }
    }
  }

  // Render a (non-projection, non-view) entity (and possibly its indices) into the appropriate
  // dictionaries of 'resultObj'.
  function renderEntityInto(artifactName, art, resultObj, env) {
    let childEnv = increaseIndent(env);
    let hanaTc = art.technicalConfig && art.technicalConfig.hana;
    let result = '';
    // Only HANA has row/column tables
    if (options.toSql.dialect === 'hana') {
      if (hanaTc && hanaTc.storeType) {
        // Explicitly specified
        result += art.technicalConfig.hana.storeType.toUpperCase() + ' ';
      } else {
        // in 'hdbtable' files, COLUMN or ROW is mandatory, and COLUMN is the default
        result += 'COLUMN ';
      }
    }
    let tableName = quoteSqlId(absoluteCdsName(artifactName), art.$location);
    definitionsDuplicateChecker.addArtifact(tableName, art.$location, artifactName)
    result += 'TABLE ' + tableName;
    result += ' (\n';
    let elements = Object.keys(art.elements).map(eltName => {
      return renderElement(artifactName, eltName, art.elements[eltName], definitionsDuplicateChecker, getFzIndex(eltName, hanaTc), childEnv);
    }).filter(s => s !== '').join(',\n');
    if (elements !== '') {
      result += elements;
    } else {
      // TODO: Already be handled by 'empty-entity' reclassification; better location
      signal(error`"${artifactName}": Entity must have at least one element that is non-virtual`, ['definitions', artifactName]);
    }
    let primaryKeys = Object.keys(art.elements).filter(name => art.elements[name].key)
                                               .filter(name => !art.elements[name]._ignore)
                                               .map(name => quoteSqlId(name, art.elements[name].$location))
                                               .join(', ');
    let uniqueFields = Object.keys(art.elements).filter(name => art.elements[name].unique && !art.elements[name]._ignore)
                                                .map(quoteSqlId)
                                                .join(', ');
    if (uniqueFields !== '') {
      result += ',\n' + childEnv.indent + 'UNIQUE(' + uniqueFields + ')'
    }
    if (primaryKeys !== '') {
      result += ',\n' + childEnv.indent + 'PRIMARY KEY(' + primaryKeys + ')'
    }
    // Append table constraints if any
    // 'CONSTRAINT <name> UNIQUE (<column_list>)
    // OR create a unique index for HDI
    for(const cn in art.$tableConstraints) {
      const c = art.$tableConstraints[cn];
      if(options.toSql.src === 'hdi') {
        resultObj.hdbindex[`${artifactName}.${cn}`] =
          `UNIQUE INVERTED INDEX ${quoteSqlId( absoluteCdsName(artifactName) + '_' + cn )} ON ${tableName} (${c.map(cpath => quoteSqlId(cpath.ref[0])).join(', ')})`;
      }
      else {
        result += ',\n' + childEnv.indent + 'CONSTRAINT ' + `${quoteSqlId( absoluteCdsName(artifactName) + '_' + cn )}` + ' UNIQUE (' +
          c.map(cpath => quoteSqlId(cpath.ref[0])).join(', ') + ')';
      }
    }
    result += env.indent + '\n)';

    if (options.toSql.dialect === 'hana') {
      result += renderTechnicalConfiguration(art.technicalConfig, childEnv);
    }

    let associations = Object.keys(art.elements).map(name => renderAssociationElement(name, art.elements[name], childEnv))
                                                .filter(s => s !== '')
                                                .join(',\n');
    if (associations !== '' && options.toSql.dialect === 'hana') {
      result += env.indent + ' WITH ASSOCIATIONS (\n' + associations + '\n';
      result += env.indent + ')';
    }
    // Only HANA has indices
    // FIXME: Really? We should provide a DB-agnostic way to specify that
    if (options.toSql.dialect === 'hana') {
      renderIndexesInto(art.technicalConfig && art.technicalConfig.hana.indexes, artifactName, resultObj, env);
    }
    resultObj.hdbtable[artifactName] = result;
  }


  // Render an extended entity into the appropriate dictionaries of 'resultObj'.
  // Only HANA SQL is currently supported.
  function renderExtendInto(artifactName, elementsObj, resultObj, env, duplicateChecker) {
    const tableName = quoteSqlId(absoluteCdsName(artifactName));
    duplicateChecker && duplicateChecker.addArtifact(tableName, undefined, artifactName)
    const elements = render.addColumns.fromElementsObj(artifactName, tableName, elementsObj, env, duplicateChecker);
    const associations = render.addAssociations(artifactName, tableName, elementsObj, env);
    if (elements.length + associations.length > 0) {
      addMigration(resultObj, artifactName, false, [...elements, ...associations]);
    }
  }

  function addMigration(resultObj, artifactName, drop, sqlArray) {
    if (!(artifactName in resultObj.migrations)) {
      resultObj.migrations[artifactName] = [];
    }
    const migrations = sqlArray.map(sql => ({ drop, sql }));
    resultObj.migrations[artifactName].push(...migrations);
  }

  function addDeletion(resultObj, artifactName, sql) {
    resultObj.deletions[artifactName] = sql;
  }

  // Retrieve the 'fzindex' (fuzzy index) property (if any) for element 'elemName' from hanaTc (if defined)
  function getFzIndex(elemName, hanaTc) {
    if (!hanaTc || !hanaTc.fzindexes || !hanaTc.fzindexes[elemName]) {
      return undefined;
    }
    if (hanaTc.fzindexes[elemName][0] instanceof Array) {
      // FIXME: Should we allow multiple fuzzy search indices on the same column at all?
      // And if not, why do we wrap this into an array?
      return hanaTc.fzindexes[elemName][hanaTc.fzindexes[elemName].length - 1];
    }
    else {
      return hanaTc.fzindexes[elemName];
    }
  }

  // Render an element 'elm' with name 'elementName' (of an entity or type, not of a
  // projection or view), optionally with corresponding fuzzy index 'fzindex' from the
  // technical configuration.
  // Ignore association elements (those are rendered later by renderAssociationElement).
  // Use 'artifactName' only for error output.
  // Return the resulting source string (no trailing LF).
  function renderElement(artifactName, elementName, elm, duplicateChecker, fzindex, env) {
    // Ignore if forHana says so, or if it is an association
    if (elm.virtual)
      elm._ignore = true; // this has the side effect, that it's also ignored in the primary key generation
    if (elm._ignore || elm.target) {
      return '';
    }
    const quotedElementName = quoteSqlId(elementName, elm.$location);
    duplicateChecker && duplicateChecker.addElement(quotedElementName, elm.$location, elementName);

    let result = env.indent + quotedElementName + ' '
                            + renderTypeReference(artifactName, elementName, elm)
                            + renderNullability(elm, true);
    if (elm.default) {
      result += ' DEFAULT ' + renderExpr(elm.default, env);
    }
    // Only HANA has fuzzy indizes
    if (fzindex && options.toSql.dialect === 'hana') {
      result += ' ' + renderExpr(fzindex, env);
    }
    return result;
  }

  // Render an element 'elm' with name 'elementName' if it is an association, in the style required for
  // HANA native associations (e.g. 'MANY TO ONE JOIN "source" AS "assoc" ON (condition)').
  // Return a string with one line per association element, or an empty string if the element
  // is not an association.
  // Any change to the cardinality rendering must be reflected in A2J mapAssocToJoinCardinality() as well.
  // TODO duplicity check
  function renderAssociationElement(elementName, elm, env) {
    let result = '';
    if (elm.target && !elm._ignore) {
      result += env.indent;
      if(elm.cardinality) {
        if(isBetaEnabled(options, 'hanaAssocRealCardinality') && elm.cardinality.src && elm.cardinality.src === 1) {
          result += 'ONE TO ';
        } else {
          result += 'MANY TO ';
        }
        if (elm.cardinality.max && (elm.cardinality.max === '*' || Number(elm.cardinality.max) > 1)) {
          result += 'MANY';
        } else {
          result += 'ONE';
        }
      } else {
        result += 'MANY TO ONE';
      }
      result += ' JOIN ';
      result += quoteSqlId(absoluteCdsName(elm.target)) + ' AS ' + quoteSqlId(elementName, elm.$location) + ` ON (`;
      result += renderExpr(elm.on, env) + ')';
    }
    return result;
  }

  // Render the 'technical configuration { ... }' section of an entity that comes as a suffix
  // to the CREATE TABLE statement (includes migration, unload prio, extended storage,
  // auto merge, partitioning, ...).
  // Return the resulting source string.
  function renderTechnicalConfiguration(tc, env) {
    let result = '';

    if (!tc) {
      return result;
    }

    // FIXME: How to deal with non-HANA technical configurations?
    // This also affects renderIndexes
    tc = tc.hana;
    if (!tc) {
      throw new Error('Expecting a HANA technical configuration');
    }
    if (tc.tableSuffix) {
      // Although we could just render the whole bandwurm as one stream of tokens, the
      // compactor has kindly stored each part (e.g. `migration enabled` `row store`, ...)
      // in its own `xpr` (for the benefit of the `toCdl` renderer, which needs semicolons
      // between parts). We use this here for putting each one one line)

      // The ignore array contains technical configurations that are illegal in HANA SQL
      let ignore = [
        'PARTITION BY KEEPING EXISTING LAYOUT',
        'ROW STORE',
        'COLUMN STORE',
        'MIGRATION ENABLED',
        'MIGRATION DISABLED'
      ];
      for (let xpr of tc.tableSuffix) {
        let clause = renderExpr(xpr, env);
        if(!ignore.includes(clause.toUpperCase())) {
          result += '\n' + env.indent + clause;
        }
      }
    }
    return result;
  }

  // Render the array `indexes` from the technical configuration of an entity 'artifactName'
  function renderIndexesInto(indexes, artifactName, resultObj, env) {
    // Indices and full-text indices
    for (let idxName in indexes || {}) {
      let result = '';
      if (indexes[idxName][0] instanceof Array) {
        // FIXME: Should we allow multiple indices with the same name at all? (last one wins)
        for (let index of indexes[idxName]) {
          result = renderExpr(insertTableName(index), env);
        }
      }
      else {
        result = renderExpr(insertTableName(indexes[idxName]), env);
      }
      // FIXME: Full text index should already be different in compact CSN
      if (result.startsWith('FULLTEXT')) {
        resultObj.hdbfulltextindex[`${artifactName}.${idxName}`] = result;
      }
      else {
        resultObj.hdbindex[`${artifactName}.${idxName}`] = result;
      }
    }

    // Insert 'artifactName' (quoted according to naming style) into the index
    // definition 'index' in two places:
    //   CDS:  unique index            "foo" on             (x, y)
    // becomes
    //   SQL:  unique index "<artifact>.foo" on "<artifact>"(x, y)
    // CDS does not need this because the index lives inside the artifact, but SQL does.
    function insertTableName(index) {
      let i = index.indexOf('index');
      let j = index.indexOf('(');
      if (i > index.length - 2 || !index[i + 1].ref || j < i || j > index.length - 2) {
        throw new Error(`Unexpected form of index: "${index}"`);
      }
      let indexName = `${absoluteCdsName(artifactName)}.${index[i + 1].ref}`;
      if (options.toSql.names === 'plain') {
        indexName = indexName.replace(/(\.|::)/g, '_');
      }
      let result = index.slice(0, i + 1); // CREATE UNIQUE INDEX
      result.push({ ref: [indexName] }); // "<artifact>.foo"
      result.push(...index.slice(i + 2, j)); // ON
      result.push({ ref: [absoluteCdsName(artifactName)] }); // <artifact>
      result.push(...index.slice(j)); // (x, y)
      return result;
    }
  }

  // Render the source of a query, which may be a path reference, possibly with an alias,
  // or a subselect, or a join operation. Use 'artifactName' only for error output.
  // FIXME: Misleading name, should be something like 'renderQueryFrom'. All the query
  // parts should probably also be rearranged.
  // Returns the source as a string.
  function renderViewSource(artifactName, source, env) {
    // Sub-SELECT
    if (source.SELECT || source.SET) {
      let result = `(${renderQuery(artifactName, source, increaseIndent(env))})`;
      if (source.as) {
        result += ` AS ${quoteSqlId(source.as)}`;
      }
      return result;
    }
    // JOIN
    else if (source.join) {
      // One join operation, possibly with ON-condition
      let result = `${renderViewSource(artifactName, source.args[0], env)}`;
      for (let i = 1; i < source.args.length; i++) {
        result = `(${result} ${source.join.toUpperCase()} `;
        if(options.toSql.dialect === 'hana')
          result += renderJoinCardinality(source.cardinality);
        result += `JOIN ${renderViewSource(artifactName, source.args[i], env)}`
        if (source.on) {
          result += ` ON ${renderExpr(source.on, env)}`;
        }
        result += ')';
      }
      return result;
    }
    // Ordinary path, possibly with an alias
    else {
      // Sanity check
      if (!source.ref) {
        throw new Error(`Expecting ref in ${JSON.stringify(source)}`);
      }
      return renderAbsolutePathWithAlias(artifactName, source, env);
    }
  }

  function renderJoinCardinality(card) {
    let result = '';
    if(card) {
      if(card.srcmin && card.srcmin === 1)
        result += 'EXACT ';
      result += card.src && card.src === 1 ? 'ONE ' : 'MANY ';
      result += 'TO ';
      if(card.min && card.min === 1)
        result += 'EXACT ';
      if(card.max)
        result += (card.max === 1) ? 'ONE ' : 'MANY ';
    }
    return result;
  }

  // Render a path that starts with an absolute name (as used for the source of a query),
  // possibly with an alias, with plain or quoted names, depending on options. Expects an object 'path' that has a
  // 'ref' and (in case of an alias) an 'as'. If necessary, an artificial alias
  // is created to the original implicit name.  Use 'artifactName' only for error output.
  // Returns the name and alias as a string.
  function renderAbsolutePathWithAlias(artifactName, path, env) {
    // This actually can't happen anymore because assoc2joins should have taken care of it
    if (path.ref[0].where) {
      throw new Error(`"${artifactName}": Filters in FROM are not supported for conversion to SQL`);
    }

    // SQL needs a ':' after path.ref[0] to separate associations
    let result = renderAbsolutePath(path, ':', env);

    // Take care of aliases
    let implicitAlias = getLastPartOfRef(path.ref);
    if (path.as) {
      // Source had an alias - render it
      result += ' AS ' + quoteSqlId(path.as);
    }
    else {
      const quotedAlias = quoteSqlId(implicitAlias);
      if (getLastPartOf(result) != quotedAlias) {
        // Render an artificial alias if the result would produce a different one
        result += ' AS ' + quotedAlias;
      }
    }
    return result;
  }

  // Render a path that starts with an absolute name (as used e.g. for the source of a query),
  // with plain or quoted names, depending on options. Expects an object 'path' that has a 'ref'.
  // Uses <seperator> (typically ':': or '.') to separate the first artifact name from any
  // subsequent associations.
  // Returns the name as a string.
  function renderAbsolutePath(path, sep, env) {
    // Sanity checks
    if (!path.ref) {
      throw new Error('Expecting ref in path: ' + JSON.stringify(path));
    }
    // Determine the absolute name of the first artifact on the path (before any associations or element traversals)
    let firstArtifactName = path.ref[0].id || path.ref[0];

    let result = quoteSqlId(absoluteCdsName(firstArtifactName));
    // store argument syntax hint in environment
    // $syntax is set only by A2J and only at the first path step after FROM clause rewriting
    const syntax = path.ref[0].$syntax;
    // Even the first step might have parameters and/or a filter
    // Render the actual parameter list. If the path has no actual parameters,
    // the ref is not rendered as { id: ...; args: } but as short form of ref[0] ;)
    // An empty actual parameter list is rendered as `()`.
    const ref = csn.definitions[path.ref[0].id] || csn.definitions[path.ref[0]];
    if (ref && ref.params) {
      result += `(${renderArgs(path.ref[0].args || {}, '=>', env, syntax)})`;
    }
    else if (['udf'].includes(syntax)) {
      // if syntax is user defined function, render empty argument list
      // CV without parameters is called as simple view
      result += '()';
    }
    if (path.ref[0].where) {
      result += `[${path.ref[0].cardinality ? (path.ref[0].cardinality.max + ': ') : ''}${renderExpr(path.ref[0].where, env)}]`;
    }
    // Add any path steps (possibly with parameters and filters) that may follow after that
    if (path.ref.length > 1) {
      result += `${sep}${renderExpr({ref: path.ref.slice(1)}, env)}`;
    }
    return result;
  }

  // Render function arguments or view parameters (positional if array, named if object/dict),
  // using 'sep' as separator for positional parameters
  function renderArgs(args, sep, env, syntax) {
    // Positional arguments
    if (args instanceof Array) {
      return args.map(arg => renderExpr(arg, env)).join(', ');
    }
    // Named arguments (object/dict)
    else if (typeof args === 'object') {
      return Object.keys(args).map(key => `${decorateParameter(key, syntax)} ${sep} ${renderExpr(args[key], env)}`).join(', ');
    }
    else {
      throw new Error('Unknown args: ' + JSON.stringify(args));
    }

    function decorateParameter(arg, syntax) {
      if(syntax === 'calcview') {
        return `PLACEHOLDER."$$${arg}$$"`
      }
      else {
        return quoteSqlId(arg);
      }
    }
  }

  // Render a single view column 'col', as it occurs in a select list or projection list.
  // Return the resulting source string (one line per column item, no CR).
  function renderViewColumn(col, env) {
    // Ignore if forHana says so
    // FIXME: Have we already filtered out associations here?
    if (col._ignore) {
      return '';
    }
    let result = '';
    let leaf = col.as || col.ref && col.ref[col.ref.length-1] || col.func;
    if(leaf && env._artifact.elements[leaf] && env._artifact.elements[leaf].virtual) {
      const renderVirtual = options.toSql && isBetaEnabled(options, 'dontRenderVirtualElements') ? !!options.toSql.renderVirtualElements : true;
      if(renderVirtual)
        // render a virtual column 'null as <alias>'
        result += env.indent + 'NULL AS ' + quoteSqlId(col.as || leaf);
    } else if (col.cast && !(options && options.toSql && options.toSql.dialect === 'sqlite')) {
      result = env.indent + 'CAST(' + renderExpr(col, env, true) + ' AS ';
      result += renderBuiltinType(col.cast.type) + renderTypeParameters(col.cast);
      result += ') ' + quoteSqlId(leaf);
    } else {
      result = env.indent + renderExpr(col, env, true);
      if (col.as) {
        result += ' AS ' + quoteSqlId(col.as);
      }
    }
    return result;
  }

  // Render a view
  function renderView(artifactName, art, env) {
    env._artifact = art;
    let viewName = quoteSqlId(absoluteCdsName(artifactName), art.$location);
    definitionsDuplicateChecker.addArtifact(viewName, art && art.$location, artifactName)
    let result = 'VIEW ' + viewName;
    result += renderParameterDefinitions(artifactName, art.params);
    result += ' AS ' + renderQuery(artifactName, art.query, env);
    let childEnv = increaseIndent(env);
    let associations = Object.keys(art.elements).filter(name => !!art.elements[name].target)
                                                .map(name => renderAssociationElement(name, art.elements[name], childEnv))
                                                .filter(s => s !== '')
                                                .join(',\n');
    if (associations !== '' && options.toSql.dialect === 'hana') {
      result += env.indent + '\nWITH ASSOCIATIONS (\n' + associations + '\n';
      result += env.indent + ')';
    }
    return result;
  }

  // Render the parameter definition of a view if any. Return the parameters in parentheses, or an empty string
  function renderParameterDefinitions(artifactName, params) {
    let result = '';
    if(params) {
      let parray = [];
      for(const pn in params) {
        const p = params[pn];
        let  pstr = 'IN ' + prepareIdentifier(pn) + ' ' + renderTypeReference(artifactName, pn, p);
        if(p.default) {
          pstr += ' DEFAULT ' + renderExpr(p.default);
        }
        parray.push(pstr);
      }
      result = '(' + parray.join(', ') + ')';
    }
    return result;
  }

  // Render a query 'query', i.e. a select statement with where-condition etc. Use 'artifactName' only for error messages.
  function renderQuery(artifactName, query, env) {
    let result = '';
    // Set operator, like UNION, INTERSECT, ...
    if (query.SET) {
      result += query.SET.args
        .map(arg => {
          // Wrap each query in the SET in parentheses that
          // - is a SET itself (to preserve precedence between the different SET operations),
          // - has an ORDER BY/LIMIT (because UNION etc. can't stand directly behind an ORDER BY)
          let queryString = renderQuery(artifactName, arg, env);
          return (arg.SET || arg.SELECT && (arg.SELECT.orderBy || arg.SELECT.limit)) ? `(${queryString})` : queryString;
        })
        .join(`\n${env.indent}${query.SET.op && query.SET.op.toUpperCase()}${query.SET.all ? ' ALL ' : ' '}`);
      // Set operation may also have an ORDER BY and LIMIT/OFFSET (in contrast to the ones belonging to
      // each SELECT)
      // If the whole SET has an ORDER BY/LIMIT, wrap the part before that in parentheses
      // (otherwise some SQL implementations (e.g. sqlite) would interpret the ORDER BY/LIMIT as belonging
      // to the last SET argument, not to the whole SET)
      if (query.SET.orderBy || query.SET.limit) {
        result = `(${result})`;
        if (query.SET.orderBy) {
          result += `\n${env.indent}ORDER BY ${query.SET.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;
        }
        if (query.SET.limit) {
          result += `\n${env.indent}${renderLimit(query.SET.limit, env)}`;
        }
      }
      return result;
    }
    // Otherwise must have a SELECT
    else if (!query.SELECT) {
      throw new Error('Unexpected query operation ' + JSON.stringify(query));
    }
    let select = query.SELECT;
    let childEnv = increaseIndent(env);
    result += 'SELECT' + (select.distinct ? ' DISTINCT' : '');
    // FIXME: We probably also need to consider `excluding` here ?
    result += '\n' +
              (select.columns||['*']).filter(s => !s._ignore)
                                     .filter(col => !(select.mixin || {})[firstPathStepId(col.ref)]) // No mixin columns
                                     .map(col => renderViewColumn(col, childEnv))
                                     .filter(s => s !== '')
                                     .join(',\n') + '\n';
    result += `${env.indent}FROM ${renderViewSource(artifactName, select.from, env)}`;
    if (select.where) {
      result += `\n${env.indent}WHERE ${renderExpr(select.where, env)}`;
    }
    if (select.groupBy) {
      result += `\n${env.indent}GROUP BY ${select.groupBy.map(expr => renderExpr(expr, env)).join(', ')}`;
    }
    if (select.having) {
      result += `\n${env.indent}HAVING ${renderExpr(select.having, env)}`;
    }
    if (select.orderBy) {
      result += `\n${env.indent}ORDER BY ${select.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;
    }
    if (select.limit) {
      result += `\n${env.indent}${renderLimit(select.limit, env)}`;
    }
    return result;
  }

  // Returns the id of the first path step in 'ref' if any, otherwise undefined
  function firstPathStepId(ref) {
    return ref && ref[0] && (ref[0].id || ref[0]);
  }

  // Render a query's LIMIT clause, which may have also have OFFSET.
  function renderLimit(limit, env) {
    let result = '';
    if (limit.rows !== undefined) {
      result += `LIMIT ${renderExpr(limit.rows, env)}`;
    }
    if (limit.offset !== undefined) {
      result += `${result !== '' ? '\n' + env.indent : ''}OFFSET ${renderExpr(limit.offset, env)}`;
    }
    return result;
  }

  // Render one entry of a query's ORDER BY clause (which always has a 'value' expression, and may
  // have a 'sort' property for ASC/DESC and a 'nulls' for FIRST/LAST
  function renderOrderByEntry(entry, env) {
    let result = renderExpr(entry, env);
    if (entry.sort) {
      result += ` ${entry.sort.toUpperCase()}`;
    }
    if (entry.nulls) {
      result += ` NULLS ${entry.nulls.toUpperCase()}`;
    }
    return result;
  }

  // Render a type.
  // Return the resulting source string.
  function renderType(artifactName, art, env) {
    // Only HANA table types are SQL-relevant
    if (!art.dbType) {
      return '';
    }
    // In Sqlite dialect do not generate table type and throw an info
    if (options.toSql.dialect === 'sqlite') {
      // TODO: Signal is not covered by tests + better location
      signal(info`"${artifactName}": HANA table types are not supported in SQLite`, ['definitions', artifactName]);
      return '';
    }
    const typeName = quoteSqlId(absoluteCdsName(artifactName), art.$location);
    definitionsDuplicateChecker.addArtifact(typeName, art && art.$location, artifactName)
    let result = 'TYPE ' + typeName + ' AS TABLE (\n';
    let childEnv = increaseIndent(env);
    if (art.elements) {
      // Structured type
      let elements = Object.keys(art.elements).map(name => renderElement(artifactName, name, art.elements[name], definitionsDuplicateChecker, null, childEnv))
                                         .filter(s => s !== '')
                                         .join(',\n') + '\n';
      if (elements !== '') {
        result += elements;
        result += env.indent + ')';
      } else {
        // TODO: Signal is not covered by tests + better location
        signal(error`"${artifactName}": HANA table type must have at least one element that is non-virtual`, ['definitions', artifactName]);
      }
    } else {
      // TODO: Signal is not covered by tests + better location
      // Non-structured HANA table type
      signal(error`"${artifactName}": HANA table types must have structured types for conversion to SQL`, ['definitions', artifactName]);
      return '';
    }
    return result;
  }

  // Render a reference to the type used by 'elm' (with name 'elementName' in 'artifactName', both used only for error messages).
  function renderTypeReference(artifactName, elementName, elm) {
    let result = '';

    // Anonymous structured type: Not supported with SQL (but shouldn't happen anyway after forHana flattened them)
    if (!elm.type) {
      if (!elm.elements) {
        throw new Error('Missing type of: ' + elementName);
      }
      // TODO: Signal is not covered by tests + better location
      signal(error`"${artifactName}.${elementName}": Anonymous structured types are not supported for conversion to SQL`, ['definitions',artifactName, 'elements', elementName]);
      return result;
    }

    // Association type
    if (elm.target) {
      // TODO: Signal is not covered by tests + better location
      // We can't do associations yet
      signal(error`"${artifactName}.${elementName}": Association and composition types are not yet supported for conversion to SQL`, ['definitions',artifactName, 'elements', elementName]);
      return result;
    }

    // If we get here, it must be a primitive (i.e. builtin) type
    if (isBuiltinType(elm.type)) {
      // cds.Integer => render as INTEGER (no quotes)
      result += renderBuiltinType(elm.type);
    } else {
      throw new Error('Unexpected non-primitive type of: ' + artifactName + '.' + elementName);
    }
    result += renderTypeParameters(elm);
    return result;
  }

  // Render the name of a builtin CDS type
  function renderBuiltinType(typeName) {
    const forHanaRenamesToEarly = {
      'cds.UTCDateTime' : 'cds.DateTime',
      'cds.UTCTimestamp' : 'cds.Timestamp',
      'cds.LocalDate' : 'cds.Date',
      'cds.LocalTime' : 'cds.Time',
    };
    const tName = forHanaRenamesToEarly[typeName] || typeName;
    const types = cdsToSqlTypes[options.toSql.dialect];
    return types && types[tName] || cdsToSqlTypes.standard[tName] || 'CHAR';
  }

  // Render the nullability of an element or parameter (can be unset, true, or false)
  function renderNullability(obj, treatKeyAsNotNull = false) {
    if (obj.notNull === undefined && !(obj.key && treatKeyAsNotNull)) {
      // Attribute not set at all
      return '';
    }
    return obj.notNull || obj.key ? ' NOT NULL' : ' NULL';
  }

  // Render (primitive) type parameters of element 'elm', i.e.
  // length, precision and scale (even if incomplete), plus any other unknown ones.
  function renderTypeParameters(elm) {
    let params = [];
    // Length, precision and scale (even if incomplete)
    if (elm.length !== undefined) {
      params.push(elm.length);
    }
    if (elm.precision !== undefined) {
      params.push(elm.precision);
    }
    if (elm.scale !== undefined) {
      params.push(elm.scale);
    }
    if (elm.srid !== undefined) {
      // Geometry types translate into CHAR on Sqlite (give them the default length of 5000)
      if (options.toSql.dialect === 'sqlite')
        params.push(5000);
      else
        params.push(elm.srid);
    }
    // Additional type parameters
    // FIXME: Not yet clear how that looks in new CSN
    for (let arg of elm.typeArguments || []) {
      params.push(arg);
    }
    return params.length === 0 ? '' : '(' + params.join(', ') + ')';
  }

  // FIXME: Reuse this together with `toCdl`.

  // Render an expression (including paths and values) or condition 'x'.
  // (no trailing LF, don't indent if inline)
  function renderExpr(x, env, inline=true, nestedExpr=false) {
    // Compound expression
    if (x instanceof Array) {
      // Simply concatenate array parts with spaces (with a tiny bit of beautification)
      // FIXME: Take this for `toCdl`, too
      let tokens = x.map(item => renderExpr(item, env, inline, nestedExpr));
      let result = '';
      for (let i = 0; i < tokens.length; i++) {
        result += tokens[i];
        // No space after last token, after opening parentheses, before closing parentheses, before comma
        if (i != tokens.length - 1 && tokens[i] !== '(' && ![')', ','].includes(tokens[i + 1])) {
          result += ' ';
        }
      }
      return result;
      // return x.map(item => renderExpr(item, env, inline, nestedExpr)).join(' ');
    }
    else if (typeof x === 'object' && x !== null) {
      if (nestedExpr && x.cast && x.cast.type)
        return renderExplicitTypeCast(renderExprObject());
      return renderExprObject();
    }
    // Not a literal value but part of an operator, function etc - just leave as it is
    // FIXME: For the sake of simplicity, we should get away from all this uppercasing in toSql
    else {
      return String(x).toUpperCase();
    }

    // Various special cases represented as objects
    function renderExprObject() {
      // Literal value, possibly with explicit 'literal' property
      if (x.val !== undefined) {
        switch (x.literal || typeof x.val) {
          case 'number':
          case 'boolean':
          case 'null':
            // 17.42, NULL, TRUE
            return String(x.val).toUpperCase();
          case 'x':
            // x'f000'
            return `${x.literal}'${x.val}'`;
          case 'date':
          case 'time':
          case 'timestamp':
            if (options.toSql.dialect === 'sqlite') {
              // simple string literal '2017-11-02'
              return `'${x.val}'`;
            } else {
              // date'2017-11-02'
              return `${x.literal}'${x.val}'`;
            }
          case 'string':
            // 'foo', with proper escaping
            return `'${x.val.replace(/'/g, "''")}'`;
          case 'object':
            if (x.val === null) {
              return 'NULL';
            }
            // otherwise fall through to
          default:
            throw new Error('Unknown literal or type: ' + JSON.stringify(x));
        }
      }
      // Enum symbol
      else if (x['#']) {
        // #foo
        // TODO: Signal is not covered by tests + better location
        // FIXME: We can't do enums yet because they are not resolved (and we don't bother finding their value by hand)
        signal(error`Enum values are not yet supported for conversion to SQL`, x.$location);
        return '';
      }
      // Reference: Array of path steps, possibly preceded by ':'
      else if (x.ref) {
        if (!x.param && !x.global) {
          if(x.ref[0] === '$user') {
          // FIXME: this is all not enough: we might need an explicit select item alias
            if (x.ref[1] === 'id') {
              if (options.toSql.user && typeof options.toSql.user === 'string' || options.toSql.user instanceof String) {
                return `'${options.toSql.user}'`;
              }
              else if ((options.toSql.user && options.toSql.user.id) && (typeof options.toSql.user.id === 'string' || options.toSql.user.id instanceof String)) {
                return `'${options.toSql.user.id}'`;
              } else {
                if(options.toSql.dialect === 'sqlite'){
                  signal(warning`The "$user" variable is not supported by SQLite. Use the "toSql.user" option to set a value for "$user.id"`);
                  return `'$user.id'`;
                } else {
                  return "SESSION_CONTEXT('APPLICATIONUSER')";
                }
              }
            }
            else if (x.ref[1] === 'locale') {
              return options.toSql.dialect === 'sqlite'
                ? options.toSql.user && options.toSql.user.locale
                  ? `'${options.toSql.user && options.toSql.user.locale}'` : `'en'`
                : "SESSION_CONTEXT('LOCALE')";
            }
          }
          else if(x.ref[0] === '$at') {
            // return current_time for all $at
            if(options.toSql.dialect === 'sqlite') {
              return 'current_timestamp';
            }
            else if(options.toSql.dialect === 'hana') {
              if(x.ref[1] === 'from') {
                return "SESSION_CONTEXT('VALID-FROM')";
              }
              else if(x.ref[1] === 'to') {
                return "SESSION_CONTEXT('VALID-TO')";
              }
            }
          }
        }
        // FIXME: We currently cannot distinguish whether '$parameters' was quoted or not - we
        // assume that it was not if the path has length 2 (
        if (firstPathStepId(x.ref) === '$parameters' && x.ref.length == 2) {
          // Parameters must be uppercased and unquoted in SQL
          return `:${x.ref[1].toUpperCase()}`;
        }
        if (x.param) {
          return `:${x.ref[0].toUpperCase()}`;
        }
        return x.ref.map(renderPathStep)
                    .filter(s => s !== '')
                    .join('.');
      }
      // Function call, possibly with args (use '=>' for named args)
      else if (x.func) {
        const funcName = smartFuncId(prepareIdentifier(x.func), options.toSql.dialect);
        return renderFunc(funcName, x, options.toSql.dialect, a => renderArgs(a, '=>', env));
      }
      // Nested expression
      else if (x.xpr) {
        return renderExpr(x.xpr, env, inline, true);
      }
      // Sub-select
      else if (x.SELECT) {
        // renderQuery for SELECT does not bring its own parentheses (because it is also used in renderView)
        return `(${renderQuery('<subselect>', x, increaseIndent(env))})`;
      }
      else if (x.SET) {
        // renderQuery for SET always brings its own parentheses (because it is also used in renderViewSource)
        return `${renderQuery('<union>', x, increaseIndent(env))}`;
      }
      else {
        throw new Error('Unknown expression: ' + JSON.stringify(x));
      }
    }

    /**
     * Renders an explicit `cast()` inside an 'xpr'.
     * @param {string} value
     */
    function renderExplicitTypeCast(value) {
      const typeRef = renderBuiltinType(x.cast.type) + renderTypeParameters(x.cast);
      return `CAST(${value} AS ${typeRef})`;
    }

    // Render a single path step 's' at path position 'idx', which can have filters or parameters or be a function
    function renderPathStep(s, idx) {
      // Simple id or absolute name
      if (typeof(s) === 'string') {
        // TODO: When is this actually executed and not handled already in renderExpr?
        const magicForHana = {
          '$now': 'CURRENT_TIMESTAMP',
          '$user.id': "SESSION_CONTEXT('APPLICATIONUSER')",
          '$user.locale': "SESSION_CONTEXT('LOCALE')",
        }
        // Some magic for first path steps
        if (idx === 0) {
          // HANA-specific translation of '$now' and '$user'
          // FIXME: this is all not enough: we might need an explicit select item alias
          if (magicForHana[s]) {
            return magicForHana[s];
          }
          // Ignore initial $projection and initial $self
          if (s === '$projection' || s === '$self') {
            return '';
          }
        }
        return quoteSqlId(s);
      }
      // ID with filters or parameters
      else if (typeof s === 'object') {
        // Sanity check
        if (!s.func && !s.id) {
          throw new Error('Unknown path step object: ' + JSON.stringify(s));
        }
        // Not really a path step but an object-like function call
        if (s.func) {
          return `${s.func}(${renderArgs(s.args, '=>', env)})`;
        }
        // Path step, possibly with view parameters and/or filters
        let result = `${quoteSqlId(s.id)}`;
        if (s.args) {
          // View parameters
          result += `(${renderArgs(s.args, '=>', env)})`;
        }
        if (s.where) {
          // Filter, possibly with cardinality
          // FIXME: Does SQL understand filter cardinalities?
          result += `[${s.cardinality ? (s.cardinality.max + ': ') : ''}${renderExpr(s.where, env)}]`;
        }
        return result;
      }
      else {
        throw new Error('Unknown path step: ' + JSON.stringify(s));
      }
    }
  }

  // Returns a copy of 'env' with increased indentation
  function increaseIndent(env) {
    return Object.assign({}, env, { indent: env.indent + '  ' });
  }

  // Return 'name' in the form of an absolute CDS name - for the 'hdbcds' naming convention,
  // this means converting '.' to '::' on the border between namespace and top-level artifact.
  // For all other naming conventions, this is a no-op.
  function absoluteCdsName(name) {
    if (options.toSql.names !== 'hdbcds') {
      return name;
    }
    let topLevelName = getTopLevelArtifactNameOf(name, csn);
    let namespaceName = getParentNameOf(topLevelName);
    if (namespaceName) {
      return `${namespaceName}::${name.substring(namespaceName.length + 1)}`;
    }
    return name;
  }

  /**
   * Prepare an identifier:
   * If 'options.toSql.names' is 'plain'
   *   - replace '.' or '::' by '_'
   * else if 'options.toSql.names' is 'quoted'
   *  - replace '::' by '.'
   * 
   * @param {String} name
   * 
   * @returns {String}
   */
  function prepareIdentifier(name) {
    // Sanity check
    if(options.toSql.dialect === 'sqlite' && options.toSql.names !== 'plain') {
      throw new Error(`Not expecting ${options.toSql.names} names for 'sqlite' dialect`);
    }
    
    switch(options.toSql.names){
      case 'plain':
        return name.replace(/(\.|::)/g, '_');
      case 'quoted':
        return name.replace(/::/g, '.');
      case 'hdbcds':
        return name;
    }
    
    throw new Error(`No matching rendering found for naming mode ${options.toSql.names}`);
  }


  // Return 'name' with appropriate "-quotes.
  // Additionally perform the following conversions on 'name'
  // If 'options.toSql.names' is 'plain'
  //   - replace '.' or '::' by '_'
  // else if 'options.toSql.names' is 'quoted'
  //   - replace '::' by '.'
  // Complain about names that collide with known SQL keywords or functions
  function quoteSqlId(name) {
    name = prepareIdentifier(name);

    switch(options.toSql.names){
      case 'plain':
        return smartId(name, options.toSql.dialect);
      case 'quoted':
        return delimitedId(name, options.toSql.dialect);
      case 'hdbcds':
        return delimitedId(name, options.toSql.dialect);
    }

    return undefined;
  }
}

module.exports = {
  toSqlDdl,
};
