const cds = require('../../cds')
let LOG = cds.log('app')
let _event

const getError = require('../error')

const _inverseTransition = transition => {
  const inverseTransition = {}
  inverseTransition.target = transition.queryTarget
  inverseTransition.queryTarget = transition.target
  inverseTransition.mapping = new Map()

  if (!transition.mapping.size) inverseTransition.mapping = new Map()

  for (const [key, value] of transition.mapping) {
    const mapped = {}
    if (value.ref) {
      mapped.ref = [key]
      if (value.transition) mapped.transition = _inverseTransition(value.transition)
      inverseTransition.mapping.set(value.ref[0], mapped)
    }
  }
  return inverseTransition
}

const revertData = (data, transition) => {
  if (!transition || !transition.mapping.size) return data
  const inverseTransition = _inverseTransition(transition)
  return Array.isArray(data)
    ? data.map(entry => _newData(entry, inverseTransition, true))
    : _newData(data, inverseTransition, true)
}

const _newSubData = (newData, key, transition, el, inverse) => {
  const val = newData[key]
  if ((!Array.isArray(val) && typeof val === 'object') || (Array.isArray(val) && val.length !== 0)) {
    const subQueryTarget = el._target
    let mapped = transition.mapping.get(key)
    if (!mapped) {
      mapped = {}
      transition.mapping.set(key, mapped)
    }
    if (!mapped.transition) {
      const subTransition = getTransition(subQueryTarget)
      mapped.transition = inverse ? _inverseTransition(subTransition) : subTransition
    }
    if (Array.isArray(val)) {
      newData[key] = val.map(singleVal => _newData(singleVal, mapped.transition, inverse))
    } else {
      newData[key] = _newData(val, mapped.transition, inverse)
    }
  }
}

const _newData = (data, transition, inverse) => {
  const newData = { ...data }
  const queryTarget = transition.queryTarget

  for (const key in newData) {
    const el = queryTarget && queryTarget.elements && queryTarget.elements[key]
    if (el && el.isAssociation) {
      _newSubData(newData, key, transition, el, inverse)
    }

    const mapped = transition.mapping.get(key)
    if (mapped && mapped.ref) {
      const value = newData[key]
      delete newData[key]
      newData[mapped.ref[0]] = value
    }
  }
  return newData
}

const _newColumns = (columns, transition, withAlias = false) => {
  const newColumns = []
  ;(columns || []).forEach(column => {
    const mapped = column.ref && transition.mapping.get(column.ref[0])
    if (mapped && mapped.ref) {
      const newColumn = { ...column }
      if (withAlias) {
        newColumn.as = column.ref[0]
      }
      newColumn.ref = mapped.ref
      newColumns.push(newColumn)
    } else if (mapped && mapped.val) {
      const newColumn = {}
      newColumn.as = column.ref[0]
      newColumn.val = mapped.val
      newColumns.push(newColumn)
    } else {
      newColumns.push(column)
    }
  })
  return newColumns
}

const _newInsertColumns = (columns, transition) => {
  const newColumns = []
  ;(columns || []).forEach(column => {
    const mapped = transition.mapping.get(column)
    if (mapped && mapped.ref) {
      newColumns.push(mapped.ref[0])
    } else if (!mapped) {
      newColumns.push(column)
    }
  })
  return newColumns
}

const _newEntries = (entries, transition) => {
  const newEntries = []
  ;(entries || []).forEach(entry => {
    newEntries.push(_newData(entry, transition))
  })
  return newEntries
}

const _newWhere = (where, transition) => {
  const newWhere = []
  ;(where || []).forEach(whereElement => {
    const mapped = whereElement.ref && transition.mapping.get(whereElement.ref[0])
    if (mapped && mapped.ref) {
      const newWhereElement = { ...whereElement }
      newWhereElement.ref = mapped.ref
      newWhere.push(newWhereElement)
    } else if (!mapped) {
      newWhere.push(whereElement)
    }
  })
  return newWhere
}

const _initialColumns = transition => {
  const columns = []
  for (const [transitionEl] of transition.mapping) {
    // REVISIT: structured elements
    if (!transition.queryTarget.elements[transitionEl] || transition.queryTarget.elements[transitionEl].isAssociation) {
      continue
    }
    columns.push({ ref: [transitionEl] })
  }
  return columns
}

const _rewriteQueryPath = (path, transitions) => {
  return path.ref.map((f, i) => {
    if (i === 0) {
      const target = transitions[0].target
      if (typeof f === 'string') {
        return target.name
      }
      if (f.id) {
        return {
          id: target.name,
          where: _newWhere(f.where, transitions[0])
        }
      }
    } else {
      if (typeof f === 'string') {
        const transitionMapping = transitions[i - 1].mapping.get(f)
        return (transitionMapping && transitionMapping.ref && transitionMapping.ref[0]) || f
      }
      if (f.id) {
        const transitionMapping = transitions[i - 1].mapping.get(f.id)
        return {
          id: (transitionMapping && transitionMapping.ref && transitionMapping.ref[0]) || f.id,
          where: _newWhere(f.where, transitions[i])
        }
      }
    }
  })
}

const _newUpdate = (query, transitions) => {
  const targetTransition = transitions[transitions.length - 1]
  const targetName = targetTransition.target.name
  const newUpdate = { ...query.UPDATE }
  newUpdate.entity = newUpdate.entity.ref
    ? {
        ...newUpdate.entity,
        ref: _rewriteQueryPath(query.UPDATE.entity, transitions)
      }
    : targetName
  if (newUpdate.data) newUpdate.data = _newData(newUpdate.data, targetTransition)
  if (newUpdate.with) newUpdate.with = _newData(newUpdate.with, targetTransition)
  if (newUpdate.where) newUpdate.where = _newWhere(newUpdate.where, targetTransition)
  Object.defineProperty(newUpdate, '_transitions', {
    enumerable: false,
    value: transitions
  })
  return newUpdate
}

const _newSelect = (query, transitions) => {
  const targetTransition = transitions[transitions.length - 1]
  const newSelect = { ...query.SELECT }
  newSelect.from = {
    ...newSelect.from,
    ref: _rewriteQueryPath(query.SELECT.from, transitions)
  }
  if (!newSelect.columns && targetTransition.mapping.size) newSelect.columns = _initialColumns(targetTransition)
  if (newSelect.columns) newSelect.columns = _newColumns(newSelect.columns, targetTransition, true)
  if (newSelect.having) newSelect.having = _newColumns(newSelect.having, targetTransition)
  if (newSelect.groupBy) newSelect.groupBy = _newColumns(newSelect.groupBy, targetTransition)
  if (newSelect.orderBy) newSelect.orderBy = _newColumns(newSelect.orderBy, targetTransition)
  if (newSelect.where) newSelect.where = _newWhere(newSelect.where, targetTransition)
  Object.defineProperty(newSelect, '_transitions', {
    enumerable: false,
    value: transitions
  })
  return newSelect
}

const _newInsert = (query, transitions) => {
  const targetTransition = transitions[transitions.length - 1]
  const targetName = targetTransition.target.name
  const newInsert = { ...query.INSERT }
  newInsert.into = newInsert.into.ref
    ? {
        ...newInsert.into,
        ref: _rewriteQueryPath(query.INSERT.into, transitions)
      }
    : targetName
  if (newInsert.columns) newInsert.columns = _newInsertColumns(newInsert.columns, targetTransition)
  if (newInsert.entries) newInsert.entries = _newEntries(newInsert.entries, targetTransition)
  Object.defineProperty(newInsert, '_transitions', {
    enumerable: false,
    value: transitions
  })
  return newInsert
}

const _newDelete = (query, transitions) => {
  const targetTransition = transitions[transitions.length - 1]
  const targetName = targetTransition.target.name
  const newDelete = { ...query.DELETE }
  newDelete.from = newDelete.from.ref
    ? {
        ...newDelete.from,
        ref: _rewriteQueryPath(query.DELETE.from, transitions)
      }
    : targetName
  if (newDelete.where) newDelete.where = _newWhere(newDelete.where, targetTransition)
  Object.defineProperty(newDelete, '_transitions', {
    enumerable: false,
    value: transitions
  })
  return newDelete
}

const _queryColumns = target => (target && target.query && target.query.SELECT && target.query.SELECT.columns) || []

// Find aliased column from the projection and set it as ref
const _renameColumns = (target, columns) =>
  columns.map(column => {
    const queryColumn =
      column.ref && _queryColumns(target).find(c => c && c.ref && c.as && c.ref[0] !== c.as && column.ref[0] === c.as)
    if (queryColumn) {
      return { ...column, ref: [...queryColumn.ref] }
    }
    return column
  })

const _merge = (aliased, inherited) =>
  inherited.reduce(
    (res, el1) =>
      (!aliased.some(el2 => el2.ref && ((el1.as && el2.ref[0] === el1.as) || (el1.ref && el2.ref[0] === el1.ref[0]))) &&
        res.concat(el1)) ||
      res,
    []
  )

const _starColumns = elements => Object.keys(elements).map(element => ({ ref: [element] }))

const _mappedValue = col => {
  const key = col.as || col.ref[0]
  const val = col.ref ? { ref: col.ref } : { val: col.val }
  return [key, val]
}

// Don't check for table in case of external services (-> force)
// Reason for hasOwnProperty: All projections have target in their prototype
// Revisit: Check if this is really intended
const _isProjection = (target, force) =>
  target.query && target.query._target && (force || !target.hasOwnProperty('@cds.persistence.table'))

const getDBTable = (target, force) => {
  if (_isProjection(target, force)) {
    return getDBTable(target.query._target, force)
  }
  return target
}

const _includeForeignKeys = (columns, target) => {
  for (const column of _queryColumns(target)) {
    const columnName = column.ref && column.ref[0]
    const el = column.as && target.elements && target.elements[column.as]
    if (columnName && el && el.name && el.type === 'cds.Association' && el.keys) {
      for (const rootKeys of el.keys) {
        // REVISIT: Check if this also works for deeply nested ones
        const rootKeyName = rootKeys.ref && rootKeys.ref[0]
        columns.push({
          ref: [`${columnName}_${rootKeyName}`],
          as: `${el.name}_${rootKeyName}`
        })
      }
    }
  }
}

const _checkForForbiddenViews = queryTarget => {
  const select = queryTarget && queryTarget.query && queryTarget.query.SELECT
  if (select) {
    if (!select.from || select.from.join || select.from.length > 1) {
      throw getError({
        code: 501,
        message: 'NON_WRITABLE_VIEW',
        target: queryTarget.name,
        args: [_event || 'INSERT|UPDATE|DELETE']
      })
    }
    if (select.where) {
      LOG._debug &&
        LOG.debug(`Ignoring where clause during ${_event || 'INSERT|UPDATE|DELETE'} on view "${queryTarget.name}".`)
    }
  }
}

const _getTransitionData = (target, columns, force, skipForbiddenViewCheck) => {
  // REVISIT: Find less param polluting way to skip forbidden view check for reads
  if (!skipForbiddenViewCheck) _checkForForbiddenViews(target)

  if (!columns.length) {
    // REVISIT: Filter out calculated fields
    const plainColumns = _queryColumns(target).filter(c => c !== '*')
    _includeForeignKeys(columns, target)
    if (_queryColumns(target).some(c => c === '*') && target.query._target) {
      // 'alias' is required to properly perform mapping
      const starColumns = _starColumns(target.query._target.elements).map(
        c => (c.as && c) || { as: c.ref[0], ref: c.ref }
      )
      columns.push(..._merge(plainColumns, starColumns))
    }
    columns.push(...plainColumns)
  }

  columns = _renameColumns(target, columns)

  if (_isProjection(target, force)) {
    return _getTransitionData(target.query._target, columns, force, skipForbiddenViewCheck)
  }

  return { target, transitionColumns: columns }
}

/**
 * If no entity definition is found, no transition is done.
 * @param queryTargetName
 */
const getTransition = (queryTarget, force, skipForbiddenViewCheck) => {
  // Never resolve unknown targets (e.g. for drafts)
  if (!queryTarget || (queryTarget.hasOwnProperty('@cds.persistence.table') && !force)) {
    return { target: queryTarget, queryTarget, mapping: new Map() }
  }
  const { target: _target, transitionColumns } = _getTransitionData(queryTarget, [], force, skipForbiddenViewCheck)
  const mapping = new Map(transitionColumns.map(key => _mappedValue(key)))
  return { target: _target, queryTarget, mapping }
}

const _entityTransitionsForTarget = (from, model, force) => {
  let previousEntity
  if (typeof from === 'string') {
    return model.definitions[from] && [getTransition(model.definitions[from], force)]
  }

  return from.ref.map((f, i) => {
    const element = f.id || f
    if (i === 0) {
      const entity = model.definitions[element]
      if (entity) {
        previousEntity = entity
        return getTransition(entity, force)
      }
    }
    if (previousEntity) {
      const entity = previousEntity.elements[element] && previousEntity.elements[element]._target
      if (entity) {
        previousEntity = entity
        return getTransition(entity, force)
      }
    }
  })
}

const resolveView = (query, model, component, force) => {
  // swap logger
  const _LOG = LOG
  LOG = cds.log(component)

  // If the query is a projection, one must follow it
  // to let the underlying service know its true entity.

  const newQuery = Object.create(query)
  if ('UPDATE' in newQuery) {
    _event = 'UPDATE'
    const transitions = _entityTransitionsForTarget(query.UPDATE.entity, model, force)
    newQuery.UPDATE = _newUpdate(newQuery, transitions)
  } else if ('SELECT' in newQuery) {
    _event = 'SELECT'
    const transitions = _entityTransitionsForTarget(query.SELECT.from, model, force)
    newQuery.SELECT = _newSelect(newQuery, transitions)
  } else if ('INSERT' in newQuery) {
    _event = 'INSERT'
    const transitions = _entityTransitionsForTarget(query.INSERT.into, model, force)
    newQuery.INSERT = _newInsert(newQuery, transitions)
  } else if ('DELETE' in newQuery) {
    _event = 'DELETE'
    const transitions = _entityTransitionsForTarget(query.DELETE.from, model, force)
    newQuery.DELETE = _newDelete(newQuery, transitions)
  }

  // restore logger and clear _event
  LOG = _LOG
  _event = undefined

  return newQuery
}

module.exports = {
  getDBTable,
  resolveView,
  getTransition,
  revertData
}
