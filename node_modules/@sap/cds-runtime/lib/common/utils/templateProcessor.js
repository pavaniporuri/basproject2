const _formatRowContext = ({ tKey, keyNames, row }) => {
  const keyValuePairs = keyNames.map(key => key + '=' + row[key])
  return tKey + '(' + keyValuePairs.join(',') + ')'
}

const _processElement = ({
  processFn,
  row,
  key,
  elements,
  picked = {},
  isRoot,
  complex = false,
  rowKeysGenerator,
  pathSegments
}) => {
  const plain = picked.plain

  if (plain) {
    const element = elements[key]

    if (!complex || typeof rowKeysGenerator !== 'function') {
      pathSegments.push(key)
    }

    processFn(row, key, element, plain, isRoot, pathSegments)
    return
  }

  const structured = picked.structured || {}

  for (const elName in structured) {
    const subPicked = structured[elName] || {}

    // keys can potentially be created
    if (!row[key]) row[key] = {}
    const subRow = row[key]
    const subElements = elements[key].elements
    const args = {
      processFn,
      row: subRow,
      key: elName,
      elements: subElements,
      picked: subPicked,
      isRoot,
      rowKeysGenerator,
      pathSegments
    }

    _processElement(args)

    // delete empty objects
    if (!Object.keys(subRow).length) delete row[key]
  }
}

const _processRow = ({ processFn, row, template, tKey, tValue, isRoot, extraKeys, rowKeysGenerator, pathSegments }) => {
  const { template: subTemplate, picked } = tValue
  const args = {
    processFn,
    row,
    key: tKey,
    elements: template.target.elements,
    picked,
    complex: !!subTemplate,
    isRoot,
    rowKeysGenerator,
    pathSegments
  }

  _processElement(args)

  // process deep
  if (subTemplate) {
    let subRows = row && row[tKey]
    subRows = Array.isArray(subRows) ? subRows : [subRows]
    const complexArgs = {
      processFn,
      rows: subRows,
      template: subTemplate,
      tKey,
      extraKeys,
      rowKeysGenerator,
      pathSegments
    }
    _processComplex(complexArgs)
  }
}

const _processComplex = ({ processFn, rows, template, tKey, extraKeys, rowKeysGenerator, pathSegments }) => {
  if (rows.length === 0) return
  const keyNames = Object.keys(template.target.keys)

  for (const row of rows) {
    if (row == null) continue

    let pathSegment
    let complexPathSegments

    if (typeof rowKeysGenerator === 'function') {
      rowKeysGenerator({ keyNames, row, template })
      const rowWithExtraKeys = { ...row, ...extraKeys }
      pathSegment = _formatRowContext({ tKey, keyNames, row: rowWithExtraKeys })
      complexPathSegments = [...pathSegments, pathSegment]
    }

    const args = {
      processFn,
      row,
      template,
      isRoot: false,
      extraKeys,
      rowKeysGenerator,
      pathSegments: complexPathSegments || pathSegments
    }

    templateProcessor(args)
  }
}

/**
 * @typedef {object} TemplateProcessorInfo
 * @property {entity} target
 * @property {Map} elements
 */

/**
 * @typedef {object} TemplateProcessor
 * @property {function} processFn
 * @property {object} row
 * @property {TemplateProcessorInfo} template
 * @property {boolean} [isRoot=true]
 * @property {object} [extraKeys]
 * @property {function} [rowKeysGenerator]
 * @property {string[]} [pathSegments=[]] - Path segments to relate the error message.
 * The path segments are used to build the error target (a relative resource path)
 */

/**
 * @param {TemplateProcessor} args
 */
const templateProcessor = ({
  processFn,
  row,
  template,
  isRoot = true,
  extraKeys,
  rowKeysGenerator,
  pathSegments = []
}) => {
  for (const [tKey, tValue] of template.elements) {
    const args = {
      processFn,
      row,
      template,
      tKey,
      tValue,
      isRoot,
      extraKeys,
      rowKeysGenerator,
      pathSegments: [...pathSegments]
    }

    _processRow(args)
  }
}

module.exports = templateProcessor
