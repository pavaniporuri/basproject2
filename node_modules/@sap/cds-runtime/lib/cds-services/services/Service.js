const cds = require('../../cds')
const LOG = cds.log('app')
const { SELECT } = cds.ql

const { selectDeepUpdateData } = require('./utils/compositionTree')
const compareJson = require('./utils/compareJson')
const { DRAFT_COLUMNS } = require('../../common/constants/draft')
const cqn2cqn4sql = require('../../common/utils/cqn2cqn4sql')
const { revertData } = require('../../common/utils/resolveView')
const { ensureDraftsSuffix } = require('./utils/draftUtils')

/**
 * Generic Service Event Handler.
 */
class ApplicationService extends cds.Service {
  constructor(name, csn, options) {
    // REVISIT: do we still need that -> likely due to legacy test?
    // If not we should remove this legacy constructor
    if (typeof name === 'object') [name, csn, options] = [csn.service, name, csn]
    const o = { kind: options.use, ...options, service: name }
    super(name, csn, o)
  }

  set model(csn) {
    const m = csn && 'definitions' in csn ? cds.linked(cds.compile.for.odata(csn)) : csn
    const db = cds.db || cds.requires.db
    if (db && db.kind === 'sqlite') cds.alpha_localized(m) // REVISIT: should move to ApplicationService?
    super.model = m
  }

  init() {
    /*
     * .before handlers (all with _initial === true)
     */
    // crud
    require('../../common/generic/auth').call(this, this)
    require('../../common/generic/etag').call(this, this)
    require('../../common/generic/input').call(this, this)
    require('../../common/generic/put').call(this, this)
    require('../../common/generic/temporal').call(this, this)
    require('../../common/generic/paging').call(this, this) // > paging must be executed before sorting
    require('../../common/generic/sorting').call(this, this)
    // draft
    require('./handlers/beforeDeleteOrCancelDraft').call(this, this)
    require('./handlers/beforeUpdateDraft').call(this, this)
    require('./handlers/beforeCreateDraft').call(this, this)

    /*
     * .on handlers
     */
    // draft
    require('./handlers/onDraftActivate').call(this, this) // > draftActivate (-> should be ACTIVATE)
    require('./handlers/onCancelDraft').call(this, this) // > CANCEL
    require('./handlers/onDraftPrepare').call(this, this) // > draftPrepare (-> should be PREPARE)
    require('./handlers/onDeleteDraft').call(this, this) // > DELETE
    require('./handlers/onPatchDraft').call(this, this) // > PATCH
    require('./handlers/onReadOverDraft').call(this, this) // > READ non-draft via navigation
    require('./handlers/onReadDraft').call(this, this) // > READ
    require('./handlers/onDraftEdit').call(this, this) // > EDIT
    require('./handlers/onCreateDraft').call(this, this) // > NEW
    // crud
    require('../../common/generic/crud').call(this, this)

    return this
  }

  /**
   * @deprecated since version 1.11.0 - use Service.prepend instead
   */
  with(serviceImpl) {
    return this.prepend(serviceImpl)
  }

  /**
   * Registers custom handlers.
   * @param {string|object|function} serviceImpl - init function to register custom handlers.
   */
  impl(serviceImpl) {
    if (typeof serviceImpl === 'string') {
      serviceImpl = require(serviceImpl)
    }

    return this.prepend(serviceImpl)
  }

  _createSelectColumnsForDelete(entity) {
    const columns = []
    for (const element of Object.values(entity.elements)) {
      if (element.isComposition) {
        if (element._target._hasPersistenceSkip) continue
        columns.push({
          ref: [element.name],
          expand: this._createSelectColumnsForDelete(element._target)
        })
      } else if (!element._isAssociationStrict && !DRAFT_COLUMNS.includes(element.name)) {
        columns.push({ ref: [element.name] })
      }
    }

    return columns
  }

  _createWhereCondition(entity, data) {
    // FIXME: need to support update on to-one association
    return Object.keys(entity.keys).reduce((prev, curr) => {
      if (!DRAFT_COLUMNS.includes(curr)) {
        prev[curr] = data[curr]
      }

      return prev
    }, {})
  }

  _diffDelete(req) {
    const query = SELECT.from(req.target)
      .columns(this._createSelectColumnsForDelete(req.target))
      .where(this._createWhereCondition(req.target, req.data))
    return cds
      .tx(req)
      .run(query)
      .then(dbState => compareJson(undefined, dbState, req.target))
  }

  async _diffUpdate(req, providedData) {
    if (cds.db) {
      try {
        await this._addPartialPersistentState(req)
      } catch (e) {
        LOG._warn && LOG.warn('Unable to calculate diff due to error: ' + e.message, e)
      }
    }
    const newQuery = cqn2cqn4sql(req.query, this.model)
    const combinedData = providedData || Object.assign({}, req.query.UPDATE.data || {}, req.query.UPDATE.with || {})
    const lastTransition = newQuery.UPDATE._transitions[newQuery.UPDATE._transitions.length - 1]
    const revertedPersistent = revertData(req._.partialPersistentState, lastTransition)
    return compareJson(combinedData, revertedPersistent, req.target)
  }

  async _diffPatch(req, providedData) {
    if (cds.db) {
      // SELECT because req.query in custom handler does not have access to _drafts
      req._.partialPersistentState = await cds
        .tx(req)
        .run(
          SELECT.from(ensureDraftsSuffix(req.target.name))
            .where(this._createWhereCondition(req.target, req.data))
            .limit(1)
        )

      return compareJson(providedData || req.data, req._.partialPersistentState, req.target)
    }
  }

  _diffCreate(req, providedData) {
    const originalData =
      providedData || (req.query.INSERT.entries && req.query.INSERT.entries.length === 1)
        ? req.query.INSERT.entries[0]
        : req.query.INSERT.entries
    return compareJson(originalData, undefined, req.target)
  }

  async _calculateDiff(req, providedData) {
    if (req.event === 'CREATE') return this._diffCreate(req, providedData)
    if (req.target._hasPersistenceSkip) return
    if (req.event === 'DELETE') return this._diffDelete(req)
    if (req.event === 'UPDATE') return this._diffUpdate(req, providedData)
    if (req.event === 'PATCH') return this._diffPatch(req, providedData)
  }

  async _addPartialPersistentState(req) {
    // REVSIIT: bind needed for execute in composition tree's _selectDeepUpdateData
    const dbtx = cds.tx(req)
    const deepUpdateData = await selectDeepUpdateData(this.model.definitions, req.query, dbtx.run.bind(dbtx), req, true)
    req._.partialPersistentState = deepUpdateData
  }
}

module.exports = ApplicationService
