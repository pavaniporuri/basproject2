const cds = require('../../../cds')
const LOG = cds.log('odata')

const serviceFactory = require('../../services/service_factory')
const OData = require('./OData')

class Dispatcher {
  /**
   * Constructs an Dispatcher for OData service.
   * New OData services will be created in case of extensibility.
   *
   * @param odata
   */
  constructor(odata) {
    this._odata = odata
  }

  _addCustomHandlers(service) {
    service._handlers = this._odata._cdsService._handlers
  }

  _getProtocolAndService(tenantId) {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve, reject) => {
      try {
        const isExtended = await cds.mtx.isExtended(tenantId)
        if (!isExtended) return resolve(false)

        const csn = await cds.mtx.getCsn(tenantId)

        const reflectedModel = cds.linked(cds.compile.for.odata(csn, { version: 'v4' }))
        const options = Object.assign({}, this._odata._options, { reflectedModel })

        // REVISIT: new cds.ApplicationService() instead of serviceFactory
        const service = serviceFactory(csn, options)
        this._addCustomHandlers(service)
        service._isExtended = true

        const edm = cds.compile.to.edm(csn, { service: service.options.service, version: 'v4' })
        const odata = new OData(edm, csn, options)
        odata.addCDSServiceToChannel(service)

        resolve(odata)
      } catch (e) {
        reject(e)
      }
    })
  }

  /**
   * Dispatch request in case of extensibility to other odata adapters.
   * @private
   */
  async dispatch(req, res) {
    if (cds.mtx && Object.keys(cds.mtx).length !== 0 && req.user && req.user.tenant) {
      // enable mtx, if not done yet
      if (!this._extMap) {
        this._extMap = new Map()
        cds.mtx.eventEmitter.on(cds.mtx.events.TENANT_UPDATED, async tenantId => {
          this._extMap.delete(tenantId)
        })
      }

      // add tenant to map, if not done yet
      if (!this._extMap.has(req.user.tenant)) {
        this._extMap.set(req.user.tenant, this._getProtocolAndService(req.user.tenant))
      }

      // await extended service promise
      let service
      try {
        service = await this._extMap.get(req.user.tenant)
      } catch (e) {
        if (LOG._error) {
          e.message = 'Unable to get service from service map due to error: ' + e.message
          LOG.error(e)
        }
        // REVISIT: use i18n
        return res.status(500).send({ error: { code: 'null', message: 'Internal Server Error' } })
      }

      // invoke extended service, if exists
      if (service) return service.process(req, res)
    }

    this._odata.process(req, res)
  }

  /**
   * Return service middleware, which can be used by node server, express, connect, ...
   * @returns {function}
   */
  getService() {
    return (req, res) => {
      this.dispatch(req, res)
    }
  }
}

module.exports = Dispatcher
