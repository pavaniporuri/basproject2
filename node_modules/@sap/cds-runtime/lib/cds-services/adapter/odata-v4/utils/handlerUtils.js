const cds = require('../../../../cds')
const { SELECT } = cds.ql
const { isDraftEnabled } = require('../../../../common/utils/draft')
const { isCustomOperation } = require('./request')
const expandToCQN = require('../odata-to-cqn/expandToCQN')
const QueryOptions = require('../okra/odata-server').QueryOptions
const { COMPLEX_PROPERTY } = require('../okra/odata-server').uri.UriResource.ResourceKind

const getTemplate = require('../../../../common/utils/template')
const { foreignKeyPropagations } = require('../../../../common/utils/foreignKeyPropagations')
const { isBacklink } = require('../../../../common/utils/composition/backlinks')

const _selectForFunction = (selectColumns, result, opReturnType) => {
  if (!Array.isArray(result)) result = [result]

  const keys = opReturnType.keys

  for (const row of result) {
    for (const entry in row) {
      if (keys[entry]) {
        continue
      }

      if (!selectColumns.includes(entry)) {
        delete row[entry]
      }
    }
  }
}

const { ensureDraftsSuffix, isDraftActivateAction } = require('../../../services/utils/draftUtils')

const _expand = (model, uriInfo) => {
  const expand = uriInfo.getQueryOption(QueryOptions.EXPAND)

  if (!expand || expand.length === 0) {
    return []
  }

  return expandToCQN(model, expand, uriInfo.getFinalEdmType())
}

const _expandForFunction = async (uriInfo, result, req, srv, opReturnType) => {
  const results = Array.isArray(result) ? result : [result]

  // REVISIT: isDraft is (always?!) undefined because opReturnType is not a string (at least always)
  const isDraft = isDraftEnabled(srv.model.definitions[opReturnType])

  const isDraftActivate = isDraftActivateAction(req)

  // REVISIT: what happens here exactly?
  for (const row of results) {
    const selectQuery = SELECT.from(isDraft && !isDraftActivate ? ensureDraftsSuffix(opReturnType.name) : opReturnType)

    for (const key in opReturnType.keys) {
      if ((!isDraft || isDraftActivate) && key === 'IsActiveEntity') {
        continue
      }
      selectQuery.where(key, '=', row[key])
    }

    const expandCqn = _expand(srv.model, uriInfo)
    selectQuery.columns(expandCqn)

    const res = await cds.tx(req).run(selectQuery)
    if (res) Object.assign(row, res[0])
  }
}

const _cleanupResult = (result, opReturnType) => {
  if (!Array.isArray(result)) result = [result]

  for (const row of result) {
    for (const element in opReturnType.elements) {
      if (opReturnType.elements[element].is2many) {
        delete row[element]
      }
    }
  }
}

const getActionOrFunctionReturnType = (pathSegments, definitions) => {
  if (!isCustomOperation(pathSegments, true)) {
    return undefined
  }

  const actionOrFunction =
    pathSegments[pathSegments.length - 1].getFunction() || pathSegments[pathSegments.length - 1].getAction()
  if (actionOrFunction) {
    const returnType = actionOrFunction.getReturnType()
    if (returnType) {
      return definitions[returnType.getType().getFullQualifiedName().toString()]
    }
  }
}

const actionAndFunctionQueries = async (req, odataReq, result, srv, opReturnType) => {
  _cleanupResult(result, opReturnType)

  if (odataReq.getQueryOptions().$select) {
    _selectForFunction(odataReq.getQueryOptions().$select.split(','), result, opReturnType)
  }
  // REVISIT: we need to read direcly from db for this, which might not be there!
  if (odataReq.getQueryOptions().$expand && cds.db) {
    await _expandForFunction(odataReq.getUriInfo(), result, req, srv, opReturnType)
  }
}

const _removeKeys = (row, template) => {
  for (const [tKey, tValue] of template.elements) {
    const { template: subTemplate } = tValue
    const val = row[tKey]

    // process complex
    if (subTemplate) {
      if (Array.isArray(val)) {
        for (const subVal of val) {
          _removeKeys(subVal, subTemplate)
        }
      } else if (val) {
        _removeKeys(val, subTemplate)
      }
      continue
    }

    // remove element from result
    delete row[tKey]
  }
}

const _getParent = (model, name) => {
  const assoc = Object.values(model.definitions[name].elements).find(
    element => element._isAssociationStrict && isBacklink(element, element._target, true)
  )
  if (assoc) return assoc._target
  return null
}

const _pick = (element, _, parent, templateElements) => {
  if (!element.isAssociation || !element.keys) {
    return
  }

  if (element._isContained || isBacklink(element, parent, true)) {
    foreignKeyPropagations(element).forEach(key => templateElements.set(key.parentFieldName, true))
  }
}

const removeContainmentKeys = (service, target, result, backlinks = []) => {
  const model = service.model

  // TODO: workaround for draft
  if (!model.definitions[target.name] || !result) {
    return
  }

  const template = getTemplate('odata-containment', service, target, { pick: _pick }, _getParent(model, target.name))

  if (template.elements.size === 0) return

  const data = Array.isArray(result) ? result : [result]

  for (const row of data) {
    _removeKeys(row, template)
  }
}

const resolveStructuredName = (pathSegments, index, nameArr = []) => {
  if (pathSegments[index].getKind() === COMPLEX_PROPERTY) {
    const prop = pathSegments[index].getProperty()
    nameArr.unshift(prop.getName())
    return resolveStructuredName(pathSegments, --index, nameArr)
  }
  return nameArr
}

module.exports = {
  _expand,
  resolveStructuredName,
  actionAndFunctionQueries,
  getActionOrFunctionReturnType,
  removeContainmentKeys
}
