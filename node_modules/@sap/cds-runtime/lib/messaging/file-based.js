const cds = require('../cds')
const LOG = cds.log('messaging')

const path = require('path')
const fs = require('fs').promises
const queued = require('./common-utils/queued')

const MessagingService = require('./service')

class FileBasedMessaging extends MessagingService {
  async init() {
    this.subscriptions = {}
    this.queued = queued()
    this.file = resolve(this.options.file || '~/.cds-msg-box')
    try {
      await fs.lstat(this.file)
    } catch (e) {
      await fs.writeFile(this.file, '\n')
    }
    cds.once('served', () => {
      this.ready = true
      this.startWatching()
    })
    return super.init()
  }

  async emit(event, ...etc) {
    const msg = this.message4(event, ...etc)
    const e = msg.event
    delete msg.event
    await this.queued(lock)(this.file)
    LOG._debug && LOG.debug('Emit', { topic: e, file: this.file })
    try {
      await fs.appendFile(this.file, `\n${e} ${JSON.stringify(msg)}`)
    } catch (e) {
      LOG._debug && LOG.debug('Error', e)
    } finally {
      unlock(this.file)
    }
  }

  on(topic, handler) {
    this.subscriptions[topic] = true
    if (!this.watcher) {
      this.watch(this.file, (event, json) => {
        // > receives all subscribed events
        super.emit({ event, ...json }).catch(e => LOG._debug && LOG.debug(e))
      })
    }
    return super.on(topic, handler)
  }

  watch(file, dispatch) {
    this.watcher = async () => {
      if (!(await touched(file, this.recent))) return // > not touched since last check
      // REVISIT: Bad if lock file wasn't cleaned up (due to crashes...)
      if (!(await this.queued(lock)(file, 1))) return // > file is locked -> try again next time
      try {
        const content = await fs.readFile(file, 'utf8')
        const lines = content.split('\n')
        const other = [] // used to collect non-matching entries
        for (const each of lines) {
          try {
            const match = /^([\s]*)([^\s]+) ({.*)/.exec(each)
            if (match) {
              const [, , event, jsonString] = match
              const json = JSON.parse(jsonString)
              if (event in this.subscriptions) {
                // Make sure to _not_ await `dispatch` -> unblock queue as fast as possible
                dispatch(event, json)
              } else other.push(each + '\n')
            }
          } catch (e) {
            // ignore invalid messages
          }
        }
        if (other.length < lines.length) await fs.writeFile(file, other.join(''))
        this.recent = await touched(file)
      } catch (e) {
        LOG._debug && LOG.debug(e)
      } finally {
        unlock(file)
      }
    }
    if (this.ready) this.startWatching()
  }

  startWatching() {
    if (!this.watching && this.watcher && this.ready) {
      this.watching = setInterval(this.watcher, this.options.interval || 500)
    }
  }

  disconnect() {
    this.watching = clearInterval(this.watching)
  }
}

const resolve = f => path.resolve(f.replace(/^~/, () => require('os').userInfo().homedir))
const sleep = ms => new Promise(resolve => setTimeout(resolve, ms))
const lock = async (file, n = 11) => {
  const lock = file + '.lock'
  try {
    while (n--) await fs.lstat(lock).then(() => n && sleep(150))
    return false
  } catch (_) {
    // lock file does not exist -> create it
    await fs.writeFile(lock, 'locked')
    return true
  }
}
const unlock = file => fs.unlink(file + '.lock').catch(() => {})
const touched = (file, t0 = 0) =>
  fs.lstat(file).then(
    ({ ctimeMs: t }) => t > t0 && t,
    () => 0
  )

module.exports = FileBasedMessaging
