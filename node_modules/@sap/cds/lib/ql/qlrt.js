/* eslint-disable no-inner-declarations */
const cds = require('..')
const lib = require ('@sap/cds-runtime')
const { inspect } = require('util')
const { extend } = cds

const { BaseStatement } = lib.statements

const Query = extend(BaseStatement).with(
  class Query extends BaseStatement {

  static get new() {
    const q = new this, cmd = this.name.toUpperCase() // NOSONAR
    return Object.defineProperties (q, {_:{value:q[cmd]}, cmd:{value:cmd}})
  }

  get cmd() {
    if (this.SELECT) return 'SELECT'
    if (this.INSERT) return 'INSERT'
    if (this.UPDATE) return 'UPDATE'
    if (this.DELETE) return 'DELETE'
    if (this.CREATE) return 'CREATE'
    if (this.DROP) return 'DROP'
    return undefined
  }

  /** Binds this query to be executed with the given service */
  bind (srv) {
    return Object.defineProperty (this,'_srv',{value:srv})
  }

  /** Turns all queries into Thenables which execute with primary db by default */
  then (r,e) {
    if (this._promised) return this._promised.then(r,e)
    const srv = this._srv || this._target._service && cds.services[this._target._service.name] || cds.db
    return this._promised = srv.run(this).then(r,e)
  }

  set _promised(v) { Object.defineProperty (this, '_promised', {value:v}) }
  set _service(v) { Object.defineProperty (this, '_service', {value:v}) }

  /** Beautifies output in REPL */
  [inspect.custom]() {
    const colors = process.env.CDS_TERM_COLORS !== false
    const cmd = this.cmd
    return (
      `{ ${cmd}: ` +
      inspect(this[cmd], { colors, depth: 22 })
        .replace(/^\w*\s/, '')
        .replace(
          /{ ref: \[([^\]]*)\] }/g,
          (_, ref) => '{ref:[' + ref.slice(1, -1) + ']}'
        )
        .replace(/{ val: ([^ ]*) }/g, '{val:$1}')
        .replace(/{ (xpr|ref|val): /g, '{$1:') +
      '}'
    )
  }

  _entity(e) { //NOSONAR
    const t = (
      !e ? cds.error(`Expected a query target but received ${e}`) :
      typeof e === 'string' ? { name: e } :
      e.name ? e : //> assumed to be a linked csn definition
      e.ref ? { name: e.ref[0] } :
      e._entityName ? { __proto__: e, name: e._entityName } :
      e._target || { name: undefined }
    )
    Object.defineProperty (this, '_target', { value:t, configurable:true })
    return t
  }

  byKey(key) {
    if (this.SELECT) this.SELECT.one = true
    if (typeof key !== 'object') {
      const e = this._target
      const ID = e.keys ? Object.keys(e.keys)[0] : 'ID'
      key = { [ID]: key }
    }
    return this.where(key)
  }

  clone() {
    const q = this.constructor.new
    if (this._srv) Object.defineProperty (q,'_srv',{value:this._srv})
    Object.assign (q._, this._)
    return q
  }

})

const Select = lib.statements.SELECT.from('x').constructor
const Insert = lib.statements.INSERT.into('x').constructor
const Update = lib.statements.UPDATE('x').constructor
const Delete = lib.statements.DELETE.from('x').constructor

const select_columns = Select.prototype.columns
const select_limit = Select.prototype.limit
const update_set = Update.prototype.set


class SELECT extends Select {

  static from(..._) { return (this.new).from(..._) }
  static _api() {
    return $((..._) => (this.new).columns(..._), {
      from: (..._) => (this.new).from(..._),
      distinct: $((...x) => $((this.new).distinct.from(...x),
        { from: (..._) => (this.new).distinct.from(..._).columns(...x) }
      ),{ from: (..._) => (this.new).distinct.from(..._) }),
      one: $((...x) => $((this.new).one.from(...x),
        { from: (..._) => (this.new).one.from(..._).columns(...x) }
      ),{ from: (..._) => (this.new).one.from(..._) }),
    })
  }

  from (entity, second, third) {
    this._entity(entity)
    this._parseEntity(entity)
    if (second) {
      if (is_projection(second)) return this.columns(second)
      else this.byKey(second)
      if (third) this.columns(third)
    } else {
      this._parseColumns (undefined,entity) // REVISIT: compatibility with overly eager implementation in cds-runtime
    }
    return this
  }

  limit (rows,offset) {
    if (rows === undefined) return this
    if (typeof rows === 'object') this._.limit = rows
    else select_limit.call(this,rows,offset)
    return this
  }

  get distinct() {
    this._.distinct = true
    return this
  }
  get one() {
    this._.one = true
    return this
  }

  /** Allows to redirect queries
   * @example
   * req.query.redirectTo ('OtherEntity')
   */
  redirectTo(entity) {
    return this.clone().from(entity)
  }

  /** @example
   * SELECT.from('Foo') .columns ((foo)=>{...})
   */
  columns(cols, ...more) {
    if (!this._.from) {
      this.from = (..._) => {
        delete this.from
        return this.from(..._).columns(cols,...more)
      }
      return this
    }
    if (!cols) return this
    if (is_function(cols)) cols = _projection4(cols, this.entity)
    if (is_array(cols)) return select_columns.call(this, ...cols)
    else return select_columns.call(this, cols, ...more)
  }

  /** @example
   * SELECT.from(...).expand(...)
   */
  expand(ref, cols, exp = 'expand') {
    const { SELECT } = this,
      columns = SELECT.columns || (SELECT.columns = [])
    const col = { ref: ref.split('.'), [exp]: cols ? _projection4(cols) : ['*'] }
    columns.push(col)
    return this
  }

  /** @example
   * SELECT.from(...).inline(...)
   */
  inline(ref, cols) {
    return this.expand(ref, cols, 'inline')
  }

  /** @example
   * SELECT.from(...).foreach(...)
   */
  foreach(callback) {
    return this.then((rows) => rows.map(callback))
  }
}

class INSERT extends Insert {

  static _api() {
    return $((..._) => (this.new).entries(..._), {
      into: (..._) => (this.new).into(..._),
    })
  }

  into(entity, data) {
    this._.into = Insert._isEntity (this._entity(entity), 'INSERT.into()')
    if (data) this.entries(data)
    return this
  }
}

class UPDATE extends Update {

  static _api() {
    return $((..._) => (this.new).entity(..._), {
      entity: (..._) => (this.new).entity(..._),
    })
  }

  entity(e, key) {
    this._.entity = Update._isEntity(this._entity(e), 'UPDATE()')
    if (key) this.byKey(key)
    return this
  }

  /** Add support for UPDATE('Foo').set ( expr | fragments | feather ) */
  with(...args) {
    return this.set(...args)
  }
  set(...args) { // NOSONAR
    if (typeof args[0] === 'object') return update_set.call(this, ...args)
    let _d; const d = {}
    let _w; const w = {}
    const cqn = this._.with = {}
    if (args.length === 1)
      for (let each of _data(args[0])) {
        const { xpr: [lhs, op, ...rhs] } = cds.parse.expr(each)
        _add (lhs.ref.join('.'), lhs, op, ...rhs)
      }
    else
      for (let i = 0; i < args.length; ++i) {
        const [, col, op] = /\s*([\w.]+)\s*([%*+-]?=)/.exec(args[i])
        _add (col, {ref:[col]}, op, { val: args[++i] })
      }
    function _add (col, lhs, op, ...rhs) {
      const v = (
        op === '=' ? (rhs.length === 1 ? rhs[0] : { xpr: rhs }) :
        op.length === 2 && op[1] === '=' ? { xpr: [ lhs, op[0], ...rhs] } :
        cds.errror('Invalid operator in UPDATE(...).set() expression: ' + op)
      )
      if (v.val) (_d=d)[col] = v.val
      else (_w=w)[col] = v
    }
    if (_w) this._.with = w
    if (_d) this._.data = d
    return this
  }
}

class DELETE extends Delete {

  static _api() {
    return $((..._) => (this.new).from(..._), {
      from: (..._) => (this.new).from(..._),
    })
  }

  from(entity, key) {
    this._.from = Delete._isEntity(this._entity(entity), 'DELETE.from()')
    if (key) this.byKey(key)
    return this
  }
}

extend(Select).with(SELECT)
extend(Insert).with(INSERT)
extend(Update).with(UPDATE)
extend(Delete).with(DELETE)

function _data(s) { // NOSONAR
  let all = [],
    start = 0,
    scope = 0,
    close = 0,
    stack = [close]
  for (let i = 0; i < s.length; ++i) {
    const c = s[i]
    if (c === ',' && !scope) {
      all.push(s.slice(start, i))
      start = i + 1
    } else if (c === "'") {
      while (i < s.length) {
        if (s[++i] === "'") {
          if (s[i + 1] === "'") ++i // NOSONAR
          else break
        }
      }
    } else if (c === '(') {
      scope++
      stack.unshift((close = ')'))
    } else if (c === '[') {
      scope++
      stack.unshift((close = ']'))
    } else if (c === '{') {
      scope++
      stack.unshift((close = '}'))
    } else if (c === close) {
      scope--
      stack.shift()
      close = stack[0]
    }
  }
  all.push(s.slice(start))
  return all
}

/* eslint no-unused-vars: off */
function _projection4(x, entity) { // NOSONAR
  if (!x || x === '*') return ['*']
  if (is_projection(x[0])) x = x[0]
  if (is_array(x)) return x.map((c) => (c.ref ? c : { ref: c.split('.') }))
  if (typeof x === 'function') {
    const columns = []
    x(
      new Proxy(x, {
        // handle top-level projections or subselects such as
        // (foo)=>{ foo('*'), foo(SELECT...).as('bar') }
        apply: (_, __, [x]) => {
          columns.push(x)
          return { as: (alias) => (x.as = alias) }
        },
        // handle top-level paths like (foo)=>{ foo.bar }
        get: (_, p) => {
          const col = { ref: [p] }
          columns.push(col)
          const nested = new Proxy(x, {
            // handle n-fold paths like (foo)=>{ foo.bar.car }
            get: (_, p) => {
              if (p === 'where') return (x) => ((col.where = _predicate4(x)), nested)
              if (p === 'as') return (alias) => ((col.as = alias), nested)
              else col.ref.push(p)
              return nested
            },
            // handle nested projections e.g. (foo)=>{ foo.bar (b=>{ ... }) }
            apply: (_, __, args) => {
              const [a, b] = args
              if (!a) col.expand = ['*']
              else if (a === '*') col.expand = ['*']
              else if (a === '.*') col.inline = ['*']
              else {
                let x = (col[/^\(?_\b/.test(a) ? 'inline' : 'expand'] = _projection4(args))
                if (b && b.levels)
                  while (--b.levels) x.push({ ...col, expand: (x = [...x]) })
              }
              return nested
            },
          })
          return nested
        },
      })
    )
    return columns
  }
  else throw new Error('SELECT w/ invalid projection argument: ' + JSON.stringify(x))
}

/**
 * Helper to create a predicate from a feather object
 */
function _predicate4(o) {
  const predicates = []
  for (let each in o) {
    predicates.push('and', { ref: each.split('.') }, '=', { val: o[each] })
  }
  return predicates.slice(1)
}


const $ = Object.assign
const is_array = Array.isArray
const is_function = (x) => typeof x === 'function'
const is_projection = (x) => typeof x === 'function' || is_array(x)


module.exports = Object.assign (function(){
  // eslint-disable-next-line no-console
  console.trace(`
  'const { SELECT, ... } = srv.ql(req)' is deprecated and superceded by 'cds.context'.
  Please use 'cds.tx(req).run( <query> )' instead.
  `)
  return module.exports
}, lib.statements, {
  SELECT: SELECT._api(),
  INSERT: INSERT._api(),
  UPDATE: UPDATE._api(),
  DELETE: DELETE._api(),
  Query,
})

if (cds.env.features.cls && cds.env.features.debug_queries) {
  const { AsyncResource } = require('async_hooks')
  const { then } = Query.prototype
  cds.extend (Query) .with (class {
    get then(){
      const q = new AsyncResource('cds.Query')
      return (r,e) => q.runInAsyncScope (then,this,r,e)
    }
  })
}
