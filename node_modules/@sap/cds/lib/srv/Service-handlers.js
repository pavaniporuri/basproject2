const cds = require('..')

class EventHandlers {

  constructor (name) {
    this._handlers = { on:[], before:[], after:[], _initial:[] } //, _error:[] }
    this.name = name
  }

  on     (...args) { return _register (this, 'on',     ...args) }
  before (...args) { return _register (this, 'before', ...args) }
  after  (...args) { return _register (this, 'after',  ...args) }
  reject (event, path) {
    const handler = (req) => req.reject(
      405, `Event "${req.event}" not allowed${req.target ? ` for entity "${req.target.name}"`: ''}.`
    )
    handler._initial = true
    return _register (this, 'before', event, path, handler)
  }

  async prepend (...impl_functions) {
    const {_handlers} = this, _new = this._handlers = { on:[], before:[], after:[], _initial:[] } //, _error:[] }
    await Promise.all (impl_functions.map (fn => is_impl(fn) && fn.call (this,this)))
    for (let each in _new) if (_new[each].length) _handlers[each] = [ ..._new[each], ..._handlers[each] ]
    this._handlers = _handlers
    return this
  }

}
module.exports = EventHandlers


//--------------------------------------------------------------------------
/** Registers event handlers. This is the central method to register handlers,
 * used by all respective public API methods, i.e. .on/before/after/reject.
 * @param {'on'|'before'|'after'} phase
 * @param {string|string[]} event
 * @param {string|string[]} path
 * @param {(req)=>{}} handler
 */
const _register = function (srv, phase, event, path, handler) { //NOSONAR
  if (!handler) [ path, handler ] = [ '*', path ] // argument path is optional
  if (!handler) throw new Error ('handler must not be null')
  if (event === 'SAVE') for (let each of ['CREATE','UPDATE']) _register (srv, phase, each, path, handler)
  else if (is_array(event)) for (let each of event) _register (srv, phase, each, path, handler)
  else if (is_array(path))  for (let each of path)  _register (srv, phase, event, each, handler)
  else {

    // canonicalize event argument
    if (event){
      if (typeof event === 'object')
        event = event.name && /[^.]+$/.exec(event.name)[0] || _expected ({event},`a string or a CSN definition`)
      else if (event === 'SELECT') event = 'READ'
      else if (event === 'INSERT') event = 'CREATE'
      else if (event === 'each' || phase === 'after' && /^\(?each\)?/.test(handler)) {
        const h=handler; event = 'READ'
        handler = (rows,req) => is_array(rows) ? rows.forEach (r => h(r,req)) : rows && h(rows,req)
      }
    }

    // canonicalize path/entity argument
    if (path) switch (typeof path) {
      case 'object': path = path.name || _expected ({path},`a string or a CSN definition`); break
      case 'string': if (path !== '*' && !path.startsWith(srv.name+'.')) path = `${srv.name}.${path}`
    }
    // actually register
    if (handler._initial) phase = '_initial'
    // REVISIT + PARKED: Should we add srv.on('error',(err)=>...)?
    // else if (event === 'error') phase = '_error'
    else if (phase === 'on') cds.emit('subscribe',srv,event)
    srv._handlers[phase].push ({ event, path, handler })
  }
  return srv
}

const _expected = (arg,type) => cds.error(`Expected ${type} for argument '${Object.keys(arg)[0]}' but got: ${Object.values(arg)[0]}`)
const is_class = x => typeof x === 'function' && x.prototype && /^class\b/.test(x)
const is_impl = x => typeof x === 'function' && !is_class(x)
const is_array = Array.isArray


//--------------------------------------------------------------------------
// Experimental stuff
// PLEASE NOTE: It is not decided yet, whether we should keep the stuff below
// => Please do not use anywhere!

EventHandlers.prototype.onSucceeded = function (...args) { return _req_on (this, 'succeeded', ...args) }
EventHandlers.prototype.onFailed = function (...args) { return _req_on (this, 'failed', ...args) }
const _req_on = (srv, succeeded_or_failed, event, path, handler) => {
  if (!handler) [path,handler] = [undefined,path]
  return srv.before (event,path, req => req.on(succeeded_or_failed,handler))
}
