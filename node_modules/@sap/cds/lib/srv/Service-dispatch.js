/**
 * This is the implementation of the `srv.dispatch(req)` method.
 * It dispatches the request through the registered event handlers.
 * @param {import('../req/event') & import('../req/impl')} req
 * @returns {Promise} resolving to the outcome/return value of last .on handler
 */
module.exports = async function dispatch (req) { //NOSONAR

  // Ensure we are in a proper transaction
  if (!this.context) {
    const txc = cds.context //> join an outer tx.context, if any, with a nested tx
    if (txc) return this.tx(txc).dispatch(req)
    else try {    //>  start a new top-level tx, which we need to commit/rollback
      const tx = cds.context = this.tx(req)
      return tx.dispatch(req) .then (tx.commit, tx.rollback)
    } finally { cds.context = txc }
  }
  // `this` is a tx from now on...
  if (!req._tx) req._tx = this

  // Inform potential listeners // REVISIT: -> this should move into protocol adapters
  const _is_root = /OData|REST/i.test(req.constructor.name)
  if (_is_root) req._.req.emit ('dispatch',req)

  // Handle batches of queries
  if (Array.isArray(req.query))
    return Promise.all (req.query.map (q => this.dispatch ({query:q,__proto__:req})))

  // Ensure we have a resolved target, if applicable
  if ((req.query || req._.path) && !req.target) _ensure_target (this,req)

  // Prepare a filter to fetch relevant handlers
  const { event, path, entity } = req
  const handlers = this._handlers, relevant = (h) => (
    (h.event === '*' || h.event === event) &&
    (h.path  === '*' || h.path === path || h.path  === entity)
  )

  // Dispatch through event handlers phases...
  const initial = handlers._initial.filter (relevant) //> REVISIT: rather overide .dispatch in subclasses
  if (initial.length) { //> ._initial handlers run in sequence
    for (const each of initial) await each.handler.call (this,req)
    if (req.errors) throw req.errors.throwable()
  }

  const before = handlers.before.filter (relevant)
  if (before.length) { //> .before handlers run in parallel
    await Promise.all (before.map (each => each.handler.call (this,req)))
    if (req.errors) throw req.errors.throwable()
  }

  const on = handlers.on.filter (relevant)
  if (on.length) { //> .on handlers run as interceptors stack
    const next = async (r=req) => { //> handlers may pass a new req object into next()
      const each = on.shift(); if (!each) return //> unhandled silently
      const x = await each.handler.call (this,r,next)
      if (!r.reply)             return next()
      if (x !== undefined)      return r.reply(x)
      if (r.results)            return r.results
      if (this._implicit_next)  return next()
    }
    await next()
    if (req.errors) throw req.errors.throwable()
  }
  else if (req.query) throw _not_implemented(this,req) //> query w/o any handlers at all

  const after = handlers.after.filter (relevant)
  if (after.length) { //> .after handlers run in parallel
    await Promise.all (after.map (each => each.handler.call (this, _arrayed_after(req) ? [req.results] : req.results, req)))
    if (req.errors) throw req.errors.throwable()
  }

  return req.results //> done
}


//
// Helpers...
//

const _not_implemented = (srv,req) => {
  const event = req.event + (req.path ? ' '+req.path : '')
  return req.reject (501, `Service "${srv.name}" has no handler for "${event}".`)
}

const _ensure_target = (srv,req) => {
  const q = req.query
  if (srv.namespace) { // ensure fully-qualified names
    const p = req._.path
    if (p) _ensure_fqn (req,'path',srv, p.startsWith('/') ? p.slice(1) : p)
    else if (q.SELECT) _ensure_fqn (q.SELECT,'from',srv)
    else if (q.INSERT) _ensure_fqn (q.INSERT,'into',srv)
    else if (q.UPDATE) _ensure_fqn (q.UPDATE,'entity',srv)
    else if (q.DELETE) _ensure_fqn (q.DELETE,'from',srv)
  }
  if (typeof q === 'object') {
    const m = srv.model, defs = m && m.definitions || {}
    req.target = cds.infer(q,defs)
  }
}

const _ensure_fqn = (x,p,srv, name = x[p]) => {
  if (typeof name === 'string') {
    if (srv.model && name in srv.model.definitions) return
    if (name.startsWith(srv.namespace)) return
    if (name.endsWith('_drafts')) return // REVISIT: rather fix test/fiori/localized-draft.test.js ?
    else x[p] = `${srv.namespace}.${name}`
  } else if (name.ref) {
    const [head] = name.ref
    head.id ? _ensure_fqn(head,'id',srv) : _ensure_fqn(name.ref,0,srv)
  }
}

const _arrayed_after = req => cds.env.features.arrayed_after && req.event === 'READ' && !Array.isArray(req.results)
