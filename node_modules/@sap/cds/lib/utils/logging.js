/**
 * Returns a trace logger for the given module if trace is switched on for it,
 * otherwise returns null. All cds runtime packages use this method for their
 * trace and debug output. It can also be used in applications like that:
 *
 *    const LOG = cds.log('sql')
 *    LOG._info && LOG.info ('whatever', you, 'like...')
 *
 * You can also specify alternate module names:
 *
 *    const LOG = cds.log('db|sql')
 *
 * Tracing can be switched on/off through env variable DEBUG:
 * Set it to a comma-separated list of modules to switch on tracing.
 * Set it to 'all' or 'y' to switch on tracing for all modules.
 *
 * @param {string} [module] the module for which a logger is requested
 * @param {string|number|{ level, prefix }} [level]  the log level to enable -> 0=off, 1=error, 2=warn, 3=info, 4=debug, 5=trace
 * @param {string} [prefix] a prefix to prepend to each log output, default: '[cds.<module>] -'
 */
module.exports = exports = function cds_log (module, level, prefix) { // NOSONAR
  if (typeof level === 'object') {
    prefix = level.prefix
    level = level.level
  }
  if (!prefix) prefix = module ? `[cds.${module.match(/^[^|]+/)}] -` : `[cds] -`
  if (!level) {
    const regex = RegExp(`\\b(y|all|${module||'any'})\\b`)
    level = (
      regex.test (process.env.LOG_TRACE) ? TRACE :
      regex.test (process.env.LOG_DEBUG || process.env.DEBUG) ? DEBUG :
      regex.test (process.env.LOG_INFO) ? INFO  :
      regex.test (process.env.LOG_WARN) ? WARN  : INFO
    )
  } else if (typeof level === 'string') {
    level = cds_log.levels [level.toUpperCase()]
  }
  const cached = cache[module]
  if (cached && cached.level === level) return cached
  const logger = cds_log.Logger (module, level, prefix)
  return cache[module] = Object.assign (cached || logger.log, logger)
}


/**
 * Shortcut to `cds.log(...).debug`, returning undefined if `cds.log(...)._debug` is false.
 * @param {string} [module] the module for which a logger is requested
 * @param {string|{ level, prefix }} [prefix] a prefix to prepend to each log output, default: '[cds.<module>] -'
 */
exports.debug = function cds_debug (module, prefix) {
  const L = this.log (module, typeof prefix === 'object' ? prefix : {prefix})
  return L._debug && L.debug
}


/**
 * Constructs a new Logger with the method signature of `{ debug, log, info, warn, error }`
 * from console. The default implementation actually maps it to `global.console`.
 * You can assign different implementations, e.g. to integrate with advanced
 * logging frameworks, for example like that:
 *
 *    cds.log.Logger = () => winston.createLogger (...)
 *
 * @param {string} [module] the module for which a logger is requested
 * @param {number} [level]  the log level to enable -> 0=off, 1=error, 2=warn, 3=info, 4=debug, 5=trace
 * @param {string} [prefix] a prefix to prepend to each log output, default: '[cds] -'
 */
/* eslint-disable no-console */
// eslint-disable-next-line no-unused-vars
exports.Logger = (module, level, prefix) => ({
  trace:  level < TRACE ? ()=>{} : (...args) => console.trace (prefix, ...args),
  debug:  level < DEBUG ? ()=>{} : (...args) => console.warn (prefix, ...args),
  log:    level < INFO  ? ()=>{} : (...args) => console.warn (prefix, ...args),
  info:   level < INFO  ? ()=>{} : (...args) => console.warn (prefix, ...args),
  warn:   level < WARN  ? ()=>{} : (...args) => console.warn (prefix, ...args),
  error:  level < ERROR ? ()=>{} : (...args) => console.error (prefix, ...args),
  _trace: level >= TRACE,
  _debug: level >= DEBUG,
  _info:  level >= INFO,
  _warn:  level >= WARN,
  _error: level >= ERROR,
  level,
})


const cache = exports.cache = {}
const { ERROR, WARN, INFO, DEBUG, TRACE } = exports.levels = {
  SILENT:0, ERROR:1, WARN:2, INFO:3, DEBUG:4, TRACE:5, VERBOSE:5
}
