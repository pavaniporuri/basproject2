const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const BuildTaskHandler = require('./buildTaskHandler')
const { hasOptionValue } = require('./util')
const { FOLDER_GEN } = require('./constants')

class BuildTaskHandlerInternal extends BuildTaskHandler {
    constructor(name, task, buildOptions) {
        super(name, task, buildOptions)
    }

    /**
     * Adds the given messages.
     * Note: Messages will be logged after all build tasks are finished.
     * @param {*} messages
     */
    pushMessages(messages) {
        if (!messages || messages === this._messages) {
            return
        }
        if (Array.isArray(messages)) {
            this._messages = this._messages.concat(messages)
        } else {
            this._messages.push(messages)
        }
    }

    /**
     * Returns whether cds env has a property with the specified value.
     * If the value is omitted the existence of the given property name is checked.
     * @param {string} qualifiedName
     * @param {any=} value
     */
    hasCdsEnvOption(qualifiedName, value) {
        return hasOptionValue(this.env.get(qualifiedName), value)
    }

    /**
     * Determines whether the given build option value has been set for this build task.
     * If the value is omitted, the existence of the given property name is checked.
     * @param {string} qualifiedName
     * @param {any=} value
     */
    hasBuildOption(qualifiedName, value) {
        return hasOptionValue(this._getBuildOption(qualifiedName), value)
    }

    /**
     * Returns the value of the given build option defined for this build task.
     * @param {string} qualifiedName
     */
    getBuildOption(qualifiedName) {
        return super._getBuildOption(qualifiedName)
    }

    /**
     * Returns whether the build results of this build plugin are created inplace
     * or in a separate staging folder which is not part of the build tasks src folder.
     */
    isStagingBuild() {
        return this.task.src !== this.task.dest
    }

    async copyNativeContent(srcDir, destDir, customFilter) {
        if (!this.isStagingBuild()) {
            return Promise.resolve()
        }
        const files = BuildTaskHandlerInternal._find(srcDir, (src) => {
            // do not copy files that:
            // - are contained in the 'buildOptions.target' folder
            // - are contained in this modules 'dest' folder
            // - are contained in some generation folder
            // - do NOT fullfill additional specific filter criteria
            // NOTE: there is no specific handling for content that is part of the 'node_modules' folder as it might be required later on, e.g. reuse model content
            return this._commonStagingBuildFilter(src, destDir) && (!customFilter || customFilter.call(this, src))
        })
        return Promise.all(
            files.map((srcFile) => {
                let relFile = path.relative(srcDir, srcFile)
                let destFile = path.join(destDir, relFile)
                return this.copy(srcFile).to(destFile)
            })
        )
    }

    options() {
        return { messages: this._messages }
    }

    _isSubDirectory(parent, child) {
        return !path.relative(parent, child).startsWith('..')
    }

    _commonStagingBuildFilter(src, destDir) {
        if (typeof src !== "string" || typeof destDir !== "string") {
            return false
        }
        if (!fs.statSync(src).isDirectory()) {
            return true //file
        }
        if (src === destDir) {
            return false
        }
        const regex = new RegExp(FOLDER_GEN + "\\b")
        if (src === this.buildOptions.target) {
            return false
        }
        return !regex.exec(path.basename(src))
    }

    static _find(srcDir, filter) {
        const files = []
        BuildTaskHandlerInternal._traverseFileSystem(srcDir, files, filter)
        return files;
    }

    static _traverseFileSystem(srcDir, files, filter) {
        let entries = []
        try {
            entries = fs.readdirSync(srcDir)
        } catch (e) {
            // ignore if not existing
        }
        entries.map(subDirEntry => path.join(srcDir, subDirEntry)).forEach((entry) => {
            BuildTaskHandlerInternal._handleResource(entry, files, filter)
        })
    }

    static _handleResource(entry, files, filter) {
        if (!filter || filter.call(this, entry)) {
            var stats = BuildTaskHandlerInternal._getResourceStatus(entry)
            if (stats.isDirectory()) {
                BuildTaskHandlerInternal._traverseFileSystem(entry, files, filter)
            } else if (stats.isFile() || stats.isSymbolicLink()) {
                files.push(entry)
            }
        }
    }

    // for testing purposes
    static _getResourceStatus(entry) {
        return fs.lstatSync(entry)
    }
}
module.exports = BuildTaskHandlerInternal
