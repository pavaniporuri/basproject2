'use strict';

/**
 * The module handles the processing of foreign key for managed associations.
 */

const { copyAnnotations } = require('../../model/modelUtils');
const { forEach } = require('../udict');
const sortByAssociationDependency = require('./sortByAssociationDependency');
const { flattenStructure } = require('./structureFlattener');
const { setProp } = require('../../base/model');

module.exports = function (csn, flatKeys, referenceFlattener, csnUtils, transformers, error) {

  // sort all associations by their dependencies
  const sortedAssociations = sortByAssociationDependency(csn, referenceFlattener);

  // generate foreign keys
  processSortedAssociations(sortedAssociations, flatKeys);


  function processSortedAssociations(sortedAssociations, flatKeys,) {
    // The map will collect all generated foreign key names for the specific path
    let generatedForeignKeyNamesForPath = {}; // map<path,[key-name]>

    sortedAssociations.forEach(item => {
      const { element, path } = item;

      if (csnUtils.isManagedAssociationElement(element) && element.keys) {
        if (flatKeys) // tackling the ref value in assoc.keys
          takeoverForeignKeysOfTargetAssociations(element, path, generatedForeignKeyNamesForPath);
        // TODO: move in separate function
        fixCardinality(element);
      }

      let arrayOfGeneratedForeignKeyNames = generateForeignKeys(item);
      generatedForeignKeyNamesForPath[item.path.join('/')] = arrayOfGeneratedForeignKeyNames;
    })

  }

  /**
   * if a key is an association and it poins to another association,
   * the foreign keys of the target association become primary keys
   * in the current association
   */
  function takeoverForeignKeysOfTargetAssociations(assoc, path, generatedForeignKeyNamesForPath) {
    let newResult = [];
    for (const keyNumber in assoc.keys) {
      let key = assoc.keys[keyNumber]
      let keyPath = path.concat('keys', keyNumber);
      let resolved = csnUtils.inspectRef(keyPath)
      let targetElement = resolved.art;
      if (targetElement) {
        if (csnUtils.isAssociation(targetElement.type)) {
          // association key
          expandAssociationKey(key);
        } else {
          newResult.push(key);
        }
      } else {
        // target element does not exist, warning is already reported, pass the key anyway
        newResult.push(key);
      }
    }

    function expandAssociationKey(key) {
      let paths = key.$paths;
      if (!paths) return;
      let lastPath = paths[paths.length - 1];
      let transitionPath = referenceFlattener.getElementTransition(lastPath)
      if (transitionPath)
        lastPath = transitionPath;
      let generatedKeys = generatedForeignKeyNamesForPath[lastPath.join('/')];
      if (!generatedKeys) return;
      generatedKeys.forEach(fkName => {
        newResult.push({ ref: [fkName] });
      })
    } // expandAssociationKey

    assoc.keys = newResult;

  }

  function fixCardinality(assoc) {
    if (assoc.notNull) {
      if (!assoc.cardinality) {
        assoc.cardinality = {};
      }
      if (assoc.cardinality.min === undefined) {
        assoc.cardinality.min = 1;
      }
    }
  }

  /**
   * Generates foreign keys and returns their names as an array
   */
  function generateForeignKeys(item) {
    let arrayOfGeneratedForeignKeyNames = [];

    const { definitionName, elementName, element, parent, path } = item;

    for (let keyIndex in element.keys) {
      let key = element.keys[keyIndex];
      let keyPath = path.concat('keys', keyIndex);

      let foreignKeyElements = flatKeys
        ? transformers.createForeignKeyElement(element, elementName, key, parent, definitionName, keyPath)
        : creareForeignKeysInStructuredOData(element, elementName, key, parent, definitionName, keyPath);

      if (!foreignKeyElements) continue;

      forEach(foreignKeyElements, (_name, foreignKeyElement) => {
        copyAnnotations(element, foreignKeyElement, true);
      })

      arrayOfGeneratedForeignKeyNames.push(...Object.keys(foreignKeyElements));
    }
    return arrayOfGeneratedForeignKeyNames;
  }

  /**
   * Generate the foreign keys for given association in structured OData flavour.
   * We do generate flattened keys, but keep the reference in the association untouched.
   * @param {*} assoc association for which keys will be generated
   * @param {*} assocName assocation name
   * @param {*} foreignKeyRef key object from the 'keys' array in the assoc
   * @param {*} parent structure where the association is
   * @param {*} defName name of the current definition
   * @param {*} pathInKeysArr path to the key in the assocaition's array of keys
   */
  function creareForeignKeysInStructuredOData(assoc, assocName, foreignKeyRef, parent, defName, pathInKeysArr) {

    let result = generateForeignKeysForRef(assoc, assocName, foreignKeyRef, pathInKeysArr);

    // Add the new elements to the definition. At the same time, check for coliding element's name
    if (parent.items) // proceed to items of such
      parent = parent.items;
    for (const [foreignKeyName, foreignKey] of Object.entries(result)) {
      // Insert artificial element into artifact, with all cross-links (must not exist already)
      if (parent.elements[foreignKeyName]) {
        const path = parent.elements.$path ? parent.elements.$path.concat([foreignKeyName]) : ['definitions', defName, 'elements', foreignKeyName];
        error(null, path, `Generated foreign key element "${foreignKeyName}" for association "${assocName}" conflicts with existing element`);
      }
      parent.elements[foreignKeyName] = foreignKey;
    }

    return result;
  }

  function generateForeignKeysForRef(assoc, assocName, foreignKeyRef, pathInKeysArr, foreignKey4 = assocName) {
    let generatedFks = Object.create(null);
    let fkArtifact = csnUtils.inspectRef(pathInKeysArr).art;
    if (csnUtils.isStructured(fkArtifact)) {
      processStuctured(fkArtifact, assocName, foreignKeyRef);
    } else {
      // built-in
      let foreignKeyElementName = `${assocName.replace(/\./g, '_')}_${foreignKeyRef.as || foreignKeyRef.ref.join('_')}`;
      newForeignKey(fkArtifact, foreignKeyElementName);
    }

    return generatedFks;

    function processStuctured(fkArtifact, assocName, foreignKeyRef) {
      let subStruct = fkArtifact.elements ? fkArtifact : csnUtils.getFinalBaseType(fkArtifact.type);
      let flatElements = flattenStructure(subStruct, subStruct.$path, csnUtils, error, undefined, fkArtifact.$path.slice(-1) || []).newFlatElements;
      for (const [flatElemName, flatElem] of Object.entries(flatElements)) {
        let foreignKeyElementName = `${assocName.replace(/\./g, '_')}_`;
        if (foreignKeyRef.as) {
          let namePathWithAlias = flatElemName.split('_');
          // TODO: resolve this with the implicit as logic
          namePathWithAlias.splice(0, 1, foreignKeyRef.as);
          foreignKeyElementName = foreignKeyElementName.concat(namePathWithAlias.join('_'));
        } else
          foreignKeyElementName = foreignKeyElementName.concat(flatElemName);

        // TODO: this is only a special case for workaround a probable bug in the sorting of assocs algo(when we take over elements from the types exposed with the
        // types exposure) once the types exposure logic is part of the renderer, this will be fixed
        if (flatElem['@odata.foreignKey4']) continue;
        newForeignKey(flatElem, foreignKeyElementName);
      }
    }

    function newForeignKey(fkArtifact, foreignKeyElementName) {
      if (fkArtifact.type === 'cds.Association' || fkArtifact.type === 'cds.Composition') {
        processAssociationOrComposition(fkArtifact, foreignKeyElementName);
        return;
      }

      let foreignKeyElement = Object.create(null);

      // Transfer selected type properties from target key element
      // FIXME: There is currently no other way but to treat the annotation '@odata.Type' as a type property.
      for (let prop of ['type', 'length', 'scale', 'precision', 'srid', 'default', '@odata.Type']) {
        if (fkArtifact[prop] != undefined) {
          foreignKeyElement[prop] = fkArtifact[prop];
        }
      }
      // If the association is non-fkArtifact resp. key, so should be the foreign key field
      for (let prop of ['notNull', 'key']) {
        if (assoc[prop] != undefined) {
          foreignKeyElement[prop] = assoc[prop];
        }
      }

      foreignKeyElement['@odata.foreignKey4'] = foreignKey4;
      setProp(foreignKeyElement, '$path', pathInKeysArr); // attach $path to the newly created element - used for inspectRef in processAssociationOrComposition
      if (assoc.$location) {
        setProp(foreignKeyElement, '$location', assoc.$location);
      }
      generatedFks[foreignKeyElementName] = foreignKeyElement;
    }

    function processAssociationOrComposition(fkArtifact, foreignKeyElementName) {
      fkArtifact.keys.forEach(keyRef => {
        let fksForAssoc = generateForeignKeysForRef(assoc, foreignKeyElementName, keyRef, keyRef.$path, foreignKey4);
        Object.assign(generatedFks, fksForAssoc);
      })
    }
  }
}
